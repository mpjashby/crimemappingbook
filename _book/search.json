[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Learn crime mapping with R",
    "section": "",
    "text": "Welcome!\nThis book will give you the knowledge and skills to effectively communicate information about crime and related topics using maps. We will cover the principles of analysing geographic information and the strengths and weaknesses of different maps for communicating it."
  },
  {
    "objectID": "index.html#who-is-this-book-for",
    "href": "index.html#who-is-this-book-for",
    "title": "Learn crime mapping with R",
    "section": "Who is this book for?",
    "text": "Who is this book for?\nThis book is for you if you are:\n\nSomeone who wants to learn how to understand patterns of crime using maps and related forms of data analysis.\nSomeone who already knows how to map crimes and would like to learn how to programme in a familiar context."
  },
  {
    "objectID": "index.html#why-use-this-book",
    "href": "index.html#why-use-this-book",
    "title": "Learn crime mapping with R",
    "section": "Why use this book?",
    "text": "Why use this book?\nThere are several books available for learning crime mapping. The advantages of using this book are that:\n\nIt teaches up-to-date crime mapping techniques. Some of the most-popular books on crime mapping were written over a decade ago and do not reflect substantial developments in the field since then.\nIt teaches crime mapping using exclusively free software (R and RStudio). Some other books teach crime mapping in expensive proprietary software that most people who need to make crime maps do not have access to.\nIt is an online book, so includes videos to introduce theoretical concepts and walk you through the process of creating different maps.\nIt uses examples from across the world, so it is not only useful to readers from one country.\nIt’s completely free to read and redistribute!"
  },
  {
    "objectID": "index.html#why-learn-crime-mapping-in-r",
    "href": "index.html#why-learn-crime-mapping-in-r",
    "title": "Learn crime mapping with R",
    "section": "Why learn crime mapping in R?",
    "text": "Why learn crime mapping in R?\nWe could make crime maps in several different apps. This includes commercial geographic information systems such as ArcGIS or MapInfo, free software such as QGIS, and data analysis programmes such as Tableau. So why learn crime mapping in a programming language like R?\nThere are several reasons:\n\nMaking maps using a programming language makes your work much more efficient, especially if (as is common in crime analysis) you need to produce similar maps periodically using updated data, or need to produce multiple similar maps for different areas or crime types.\nR is free. This can be important for people working in agencies with very limited budgets for software for data analysis.\nR has extensive mapping capabilities, supported by a large team of friendly experts who provide online support.\nR is good for other types of data analysis, so everything you learn here can be used for analysing crime data using techniques that are unrelated to maps.\n\nLearning a programming language like R involves a little extra work at the start, but this book is written to make this as easy as possibly by gently introducing you to programming ideas a little at a time. Once you’ve got started, you’ll find mapping crime in this way makes it much easier to advance further in the future."
  },
  {
    "objectID": "index.html#how-to-use-this-book",
    "href": "index.html#how-to-use-this-book",
    "title": "Learn crime mapping with R",
    "section": "How to use this book",
    "text": "How to use this book\nThere are two ways to use this book.\n\nYou can read it as you would any other technical how-to book, by reading through each chapter and working through each exercise in RStudio on your computer or online.\nYou can work through each chapter as an interactive tutorial in RStudio, getting immediate feedback on each exercise. The interactive tutorials also include quizzes to help you check your understanding.\n\nIf you want to use the interactive tutorials, there are a few extra set-up steps to work through at the bottom of this page. They will only take a few minutes.\nI recommend using the interactive tutorials if you can. The interactive tutorials are used for teaching crime mapping to BSc Crime and Security Science students at University College London so they have been tested by hundreds of people learning crime mapping before you."
  },
  {
    "objectID": "00_setup/index.html#step-1-install-r",
    "href": "00_setup/index.html#step-1-install-r",
    "title": "Install the software needed for this book",
    "section": "Step 1: install R",
    "text": "Step 1: install R\nThe first step is to download and install R, a programming language designed for analysing and visualising data, including making maps. To install R, visit the R website and download R for either Windows or Mac, depending on what type of computer you are using. If you already have R installed on your computer, please update it to the latest release.\nThis video talks you through the process of installing R:"
  },
  {
    "objectID": "00_setup/index.html#step-2-install-rstudio",
    "href": "00_setup/index.html#step-2-install-rstudio",
    "title": "Install the software needed for this book",
    "section": "Step 2: install RStudio",
    "text": "Step 2: install RStudio\nThe next step is to download RStudio, an app that you can use to work with the R programming language more efficiently. Download RStudio Desktop for your computer from the Posit website (that’s the company that makes RStudio) and install. If you already have RStudio Desktop installed on your machine, please update it to the latest release.\nThis video talks you through the process of installing RStudio:"
  },
  {
    "objectID": "00_setup/index.html#step-3-install-rtools-windows-only",
    "href": "00_setup/index.html#step-3-install-rtools-windows-only",
    "title": "Install the software needed for this book",
    "section": "Step 3: install RTools (Windows only)",
    "text": "Step 3: install RTools (Windows only)\nIf you are using a Windows computer you should install Rtools, which will be needed by RStudio for some tutorials. If you are using a Mac or Linux computer, you do not need to install Rtools.\nTo install RTools:\n\nDownload the latest version from the R website and open the downloaded file.\nFollow the installation instructions (accept all the default options).\nOpen RStudio.\nFind the panel (in the bottom-left) marked Console.\nFind the > symbol at the bottom of that panel.\nCopy and paste the following code to the right of the > symbol:\n\nwrite('PATH=\"${RTOOLS40_HOME}\\\\usr\\\\bin;${PATH}\"', file = \"~/.Renviron\", append = TRUE)\n\nPress Enter."
  },
  {
    "objectID": "00_setup/index.html#if-you-cannot-install-software-on-your-computer",
    "href": "00_setup/index.html#if-you-cannot-install-software-on-your-computer",
    "title": "Install the software needed for this book",
    "section": "If you cannot install software on your computer",
    "text": "If you cannot install software on your computer\nYou may not be able to install software on the computer you want to use for crime mapping, or you may prefer not to for various reasons. In that case, you can run RStudio online using Posit Cloud. Posit Cloud is free for a certain number of hours each month, after which you can pay to continue using it.\nUsing Posit Cloud allows you to avoid the installation steps for R, RStudio and RTools above, but remember that since Posit Cloud operates online, you should not use it work on confidential or personal data unless you have the necessary permission to do so."
  },
  {
    "objectID": "00_setup/index.html#running-the-interactive-tutorials",
    "href": "00_setup/index.html#running-the-interactive-tutorials",
    "title": "Install the software needed for this book",
    "section": "Running the interactive tutorials",
    "text": "Running the interactive tutorials\nIf you are going to use this book as you would any other technical how-to book, you can move ahead to the next chapter now. If you are going to use the interactive tutorials that accompany this book, there is one final step to set them up:\n\nOpen RStudio.\nFind the panel (in the bottom-left) marked Console.\nFind the > symbol at the bottom of that panel.\nCopy and paste the following code to the right of the > symbol:\n\nsource(\"https://github.com/mpjashby/crimemapping/raw/main/inst/initialise.R\")\n\nPress Enter.\n\n\nIt will take a few minutes for the tutorials to be set up. Once the process is complete you will see a message telling you this."
  },
  {
    "objectID": "01_getting_started/index.html#welcome-to-this-course",
    "href": "01_getting_started/index.html#welcome-to-this-course",
    "title": "1  Getting started",
    "section": "1.1 Welcome to this course",
    "text": "1.1 Welcome to this course\nWelcome to this course on crime mapping! This course uses interactive tutorials like this one to help you learn about using maps and spatial analysis techniques to understand crime. Watch this video to learn more about the course."
  },
  {
    "objectID": "01_getting_started/index.html#why-put-crimes-on-maps",
    "href": "01_getting_started/index.html#why-put-crimes-on-maps",
    "title": "1  Getting started",
    "section": "1.2 Why put crimes on maps?",
    "text": "1.2 Why put crimes on maps?\nThis course is about how we can use maps and other spatial analysis tools to help understand, prevent and respond to crime. Watch this video to understand why spatial analysis is a useful tool for understanding crime.\n\n\nWeisburd, D. (2015). The law of crime concentration and the criminology of place. Criminology, 53(2), 133-157.\nJohnson, S. (2010). A brief history of the analysis of crime concentration. European Journal of Applied Mathematics, 21(4-5), 349.\nFarrell, G. (2015). Crime concentration theory. Crime Prevention and Community Safety, 17(4), 233-248."
  },
  {
    "objectID": "01_getting_started/index.html#why-is-crime-concentrated-in-space",
    "href": "01_getting_started/index.html#why-is-crime-concentrated-in-space",
    "title": "1  Getting started",
    "section": "1.3 Why is crime concentrated in space?",
    "text": "1.3 Why is crime concentrated in space?\nWhy is crime concentrated in space? Watch this video to find out more about how our environment influences opportunities for crime and how that causes clusters of different crimes.\n\n\nSantos, R. B. (2015). Routine Activity Theory: A Cornerstone of Police Crime Analyst Work. In The Criminal Act:\nCohen, L. E., and Felson, M. (1979). Social Change and Crime Rate Trends: A Routine Activity Approach. American Sociological Review, 44(4), 588–608."
  },
  {
    "objectID": "01_getting_started/index.html#finding-your-way-around-rstudio",
    "href": "01_getting_started/index.html#finding-your-way-around-rstudio",
    "title": "1  Getting started",
    "section": "1.4 Finding your way around RStudio",
    "text": "1.4 Finding your way around RStudio\nWe will use RStudio for almost all of this course. Watch this video to find your way around the different panels in the RStudio window.\n\n\n1.4.1 Slightly adjusting how RStudio works\nBefore we start using RStudio, we should make a few changes to how it is set up that will make it easier to fix any mistakes we make while coding. To do this, click on the Tools menu in RStudio and then on Global Options…. In the dialogue box that opens, click on General in the left-hand panel if General is not selected already.\n\n\n\nIn the “Workspace” section of the right-hand panel, find an option that says “Restore .RData into workspace at startup” and make sure the check box to the left of that option is not checked. On the next line down, click the drop-down menu labelled “Save workspace to .RData on exit:” and choose the option Never. Click Apply and then OK to close the dialogue box.\n\nThe RStudio IDE Cheat Sheet highlights some of the features available in RStudio and gives a list of available keyboard short-cuts.\nWriting Code in RStudio is a webinar that talks you through RStudio in more detail."
  },
  {
    "objectID": "01_getting_started/index.html#navigating-these-tutorials",
    "href": "01_getting_started/index.html#navigating-these-tutorials",
    "title": "1  Getting started",
    "section": "1.5 Navigating these tutorials",
    "text": "1.5 Navigating these tutorials\nThe tutorials that make up this course include short chunks of R code that you can run directly in the tutorial window. To run the code in each chunk, just click the Run Code button in the top-right corner of each chunk. If you want to re-run a chunk of code, you can click the Start Over button in the top-left corner of each chunk. Some of the chunks will have pre-filled code for you to run, while for others you will be asked to type the code needed to complete a task based on what you have already learned.\nWhen you click Run Code, the output of the chunk will appear below it (there may be a delay of a few seconds for more-complicated chunks).\n\nSome of the tutorials include boxes like this one that contain information that it is particularly important for you to know to avoid common mistakes in writing code. Pay special attention to these points and remember to ask questions if anything isn’t clear.\n\n\n\nMore information you might like to know <- click here\n\n\nIn these tutorials you will also see lines marked ‘Extra detail’ that you can click on to find out more information about a particular issue. This is generally information that you do not need to know to complete the tutorial, but which might be useful in other circumstances or which might answer some questions that you have. You can skip these boxes if you want to, or come back to them later if you have a question."
  },
  {
    "objectID": "01_getting_started/index.html#in-summary",
    "href": "01_getting_started/index.html#in-summary",
    "title": "1  Getting started",
    "section": "1.6 In summary",
    "text": "1.6 In summary\nNow that you know why crime mapping is useful for understanding crime, why crime is typically concentrated in space and how to find your way around RStudio, in the next tutorial we will produce our first crime map in R.\nIf you’re not feeling too confident at this point in the course, don’t worry – learning something new is always a bit of a roller coaster and there is lots of help available in subsequent tutorials.\n\n\n\n\nStats Illustrations by Allison Horst licensed under the Creative Commons Attribution licence."
  },
  {
    "objectID": "02_your_first_crime_map/index.html#introduction",
    "href": "02_your_first_crime_map/index.html#introduction",
    "title": "2  Your first crime map",
    "section": "2.1 Introduction",
    "text": "2.1 Introduction\nIn this tutorial we will use R to produce a simple crime map. To do this we will skip over lots of the detail of how R works and what choices we should make in creating maps. We will return to all these details in future sessions, so for-now please don’t worry about understanding every single line of code. Everything will become clear as we work through the tutorials in this course.\nThe map we’re going to create shows the locations of four homicides in downtown Atlanta in 2019:\n\nTo start off with, watch this video that walks through the code needed to make this map. Don’t worry if there are things in the video that you don’t understand – the rest of this tutorial will explain each line of code in turn.\n\n\n2.1.1 Running code in the interactive tutorials\nIn the video above you saw code being run in RStudio, but to save switching between the interactive tutorials and the RStudio console, the the tutorials includes short chunks of R code that you can run directly in this window. We will use these chunks of code to walk through the code we need to produce a map. To run the code in each chunk, just click the Run Code button in the top-right corner of each chunk. If you want to re-run a chunk of code, you can click the Start Over button in the top-left corner of each chunk.\nWhen you click Run Code, the output of the chunk will appear below it (there may be a delay of a few seconds for more-complicated chunks)."
  },
  {
    "objectID": "02_your_first_crime_map/index.html#loading-crime-data",
    "href": "02_your_first_crime_map/index.html#loading-crime-data",
    "title": "2  Your first crime map",
    "section": "2.2 Loading crime data",
    "text": "2.2 Loading crime data\n\n2.2.1 Loading packages\nBefore we can work with our data, we first load packages of functions for use in the analysis. To load these packages, click Run Code. This will produce various messages, all of which you can safely ignore for now.\n# Load the R packages we need to analyse this data\nlibrary(ggspatial)\nlibrary(sf)\nlibrary(tidyverse)\n\n\nWhat do these messages mean?\n\n\nFor now you don’t need to worry about these messages, but if you really want to know what they mean …\n\n\n\n\nSome R packages make use of other apps and utilities on your computer. For example, the sf package makes use of a piece of software call GDAL that is used for managing spatial data. So that you know which version of GDAL is being used, sf prints a message telling you.\nThe tidyverse package itself loads several packages that are commonly used together for analysing data. When you load tidyverse, it will print a message telling you which packages it has loaded, along with the version number for each package. It also prints a message saying if any functions from the tidyverse packages have replaced (“masked”) any functions from packages that were previously loaded.\nIn general, R packages use start-up messages to remind you of information that is not likely to be critical to your work, but which it might be useful to know at some point in the future.\n\n\n\n\n\n2.2.2 Loading data\nThe first task in creating any crime map is to obtain the crime and other data necessary. In many cases preparing the data for analysis and mapping will be a substantial task, but in this case we are going to use some pre-prepared crime data together with a pre-drawn street map (which we will ask R to download automatically when it draws the final map).\nThe data we will use will be records of homicides in the Downtown neighbourhood of Atlanta, Georgia, in 2019. We can load the homicide data using the read_csv() function.\n# Download the data directly from a URL and store it as an object\nhomicides <- read_csv(\"https://github.com/mpjashby/crimemapping/raw/main/inst/extdata/downtown_homicides.csv\")\nThe read_csv() function loads data from a file and prints a message showing the name of each column in the data and the type of data (number, text etc.) in each column. Again, you can ignore this message for now.\nWe have stored the results of the read_csv() function in an R object called homicides. An object in R is anything that stores any type of data. There are many types of objects, but for this tutorial we don’t need to explore these in any more detail. All you need to remember for now is that objects store data and functions do things.\n\n\n2.2.3 Viewing the data\nTo check the data has been loaded correctly, we can view the loaded data using the head() function. By default, head() prints the first six rows of the data stored in an object.\n# Display the data\nhead(homicides)\nThe data contain four columns: a unique identifier for a homicide, a label describing when and where that homicide occurred, and the longitude and latitude of the homicide location. Depending on the width of your screen, you may need to click on the ‘▸’ symbol to view all the columns in the data. We can use this data to plot the homicides on a map.\n\nIn the code head(homicides), there are no quote marks around the word homicides.\nAlmost all programming languages will interpret words differently depending on whether they have quotes around them or not. In this case, if you type the code head(homicides) then R will print the first few rows of the data stored in the homicides object.\nOn the other hand, if you type the code head(\"homicides\") or head('homicides'), R will interpret this as an instruction to print the first few elements of the literal text ‘homicides’. Since the text ‘homicides’ contains only one element (more about that later), head(\"homicides\") will just print the word ‘homicides’."
  },
  {
    "objectID": "02_your_first_crime_map/index.html#processing-the-data",
    "href": "02_your_first_crime_map/index.html#processing-the-data",
    "title": "2  Your first crime map",
    "section": "2.3 Processing the data",
    "text": "2.3 Processing the data\nBefore we can plot the data on a map, we have to complete some pre-processing steps. Having to process data before being able to analyse or visualise it is common in all types of data analysis, but spatial analysis often involves additional processing that takes account of the special features of spatial data.\n\n2.3.1 Converting the data into a spatial format\nTwo data-processing tasks are needed to produce this map. The first is to convert the data into a simple features or SF object, which is a special type of R object that can be used by functions that process spatial data. We will cover the details of the st_as_sf() function that converts our data into into an SF object later on. Click Run Code to convert the data into SF format.\n# Convert the data to a simple features object, which we can use in functions \n# that work on spatial data\nhomicides_sf <- st_as_sf(\n  homicides, \n  coords = c(\"longitude\", \"latitude\"), \n  crs = \"EPSG:4326\"\n)\nWhen you ran the code above, it looked like nothing happened. This is because the results of the code are stored in the homicides_sf object. Do you remember what R code to use to view the first few rows of this object?\n\nIf you cannot remember how to view the contents of an object, you can click on the Solution button to get help.\nAs you go through these tutorials, try to avoid using the Solution button unless you have tried to input the correct code yourself. You will learn much more if you try to work out the answer by referring back to an earlier page in the tutorial or to your own notes.\nDon’t worry about getting the answer wrong – nothing bad will happen if you run the wrong code in this tutorial and you can have as many attempts as you like to get the answer right.\n\n# To view an object in R, use the `head()` function. To view the contents of the\n# homicides object, copy the next line into the box below and click Run Code.\nhead(homicides_sf)\nThe data looks identical to before running the function st_as_sf(), except that the two columns called longitude and latitude have disappeared and there is now an extra column called geometry. The geometry column is important because lots of functions in R can recognise that the geometry column represents a location on the surface of the earth that can be used to analyse and map data in space.\n\n\n2.3.2 Changing the data projection\nThe geometry column in the homicides_sf object represents locations on the surface of the earth using co-ordinates (pairs of numbers). In this case, the co-ordinates are expressed as longitudes and latitudes, but there are lots of other types of co-ordinates (known as co-ordinate reference systems).\nWe’ll learn more about co-ordinate reference systems in a future tutorial, but for now it’s enough to know that each different system has advantages and disadvantages. To make the homicide locations easier to add to a map, we are going to first transform the co-ordinates from longitudes and latitudes to a co-ordinate reference system that is specifically designed for mapping data for the US state of Georgia.\nTo do this, we will use the st_transform() function, together with a code representing the co-ordinate reference system we want to use (you don’t need to understand this code at this stage).\nhomicides_sf_trans <- st_transform(homicides_sf, \"EPSG:26967\")\n\nhead(homicides_sf_trans)\nAgain, the data looks almost identical, except that the values in the geometry column have changed (you don’t need to understand yet the details of how these numbers are different). Now that we’ve completed the data processing, we can go on to produce the map itself."
  },
  {
    "objectID": "02_your_first_crime_map/index.html#draw-the-map",
    "href": "02_your_first_crime_map/index.html#draw-the-map",
    "title": "2  Your first crime map",
    "section": "2.4 Draw the map",
    "text": "2.4 Draw the map\nWe are now ready to produce our map of homicides in downtown Atlanta. So that people viewing the map will understand where the homicides occurred, we will plot the homicides on top of a base layer showing streets, parks and other geographic features obtained from an online web mapping service. Click Run Code to create the map.\nggplot(homicides_sf_trans) + \n  annotation_map_tile(type = \"osm\", zoom = 15) + \n  geom_sf_label(\n    aes(label = label), \n    lineheight = 1, \n    size = 2.5, \n    hjust = 1, \n    vjust = 0\n  ) + \n  geom_sf(colour = \"white\", fill = \"orangered1\", size = 4, shape = 21) + \n  scale_x_continuous(expand = expansion(mult = 0.5)) + \n  scale_y_continuous(expand = expansion(mult = 0.2)) + \n  labs(\n    title = \"Homicides in Downtown Atlanta, 2019\",\n    caption = \"Background map by OpenStreetMap\"\n  ) +\n  theme_void()\nYou can change the appearance of the map by changing various parts of the code above and clicking Run Code again. For example, you can change the colour of the points that mark the homicides by changing the code fill = \"orangered1\" to fill = \"mediumblue\", or change the base map to a different style by changing the code type = \"osm\" to type = \"cartolight\". Each time you change part of the code, click Run Code to see what changes on the map."
  },
  {
    "objectID": "02_your_first_crime_map/index.html#putting-the-code-together",
    "href": "02_your_first_crime_map/index.html#putting-the-code-together",
    "title": "2  Your first crime map",
    "section": "2.5 Putting the code together",
    "text": "2.5 Putting the code together\nNow we have walked through the different parts of the code, we can create a map from scratch in a single block of code. In this example, we will map homicides from in Glenrose Heights neighbourhood of Atlanta, and a different style of base map. Since the area covered by the map is derived from the data itself, the extent of the map will update automatically.\n# Load the R packages we need to analyse this data\nlibrary(ggspatial)\nlibrary(sf)\nlibrary(tidyverse)\n\n# Download the data directly from a URL and store it as an object\nhomicides <- read_csv(\"https://github.com/mpjashby/crimemapping/raw/main/inst/extdata/glenrose_heights_homicides.csv\")\n\n# Convert the data to a simple features object, which we can use in functions \n# that work on spatial data\nhomicides_sf <- st_as_sf(\n  homicides, \n  coords = c(\"longitude\", \"latitude\"), \n  crs = \"EPSG:4326\"\n)\n\n# Transform the data to a co-ordinate reference system for the state of Georgia\nhomicides_sf_trans <- st_transform(homicides_sf, \"EPSG:26967\")\n\n# Plot the map\nggplot(homicides_sf_trans) + \n  annotation_map_tile(type = \"osm\", zoom = 15) + \n  geom_sf_label(\n    aes(label = label), \n    lineheight = 1, \n    size = 2.5, \n    hjust = 1, \n    vjust = 0\n  ) + \n  geom_sf(colour = \"white\", fill = \"mediumblue\", size = 4, shape = 21) + \n  scale_x_continuous(expand = expansion(mult = 1.5)) + \n  scale_y_continuous(expand = expansion(mult = 0.2)) + \n  labs(\n    title = \"Homicides in Glenrose Heights, 2019\",\n    caption = \"Background map by OpenStreetMap\"\n  ) +\n  theme_void()"
  },
  {
    "objectID": "02_your_first_crime_map/index.html#in-summary",
    "href": "02_your_first_crime_map/index.html#in-summary",
    "title": "2  Your first crime map",
    "section": "2.6 In summary",
    "text": "2.6 In summary\n\nWell done – you have finished your first mapping tutorial. You may not have understood every line of code in this tutorial, but we will cover them all in more detail over the rest of this course. By the end of the tutorials, you will be able to write code like this to create many different types of crime map.\n\nIn this tutorial you have learned how to load data into R, prepare it for use in making a map and then used it to make your first crime map of this course.\nThe map we have produced in this tutorial is effective for showing the locations of just a few crimes, but is too limited to show more complicated patterns or larger datasets. In the following tutorials, we will learn how to produce more sophisticated maps and spatial analysis. We will also learn how each of the functions that we have used in this tutorial work."
  },
  {
    "objectID": "03_data_wrangling/index.html#introduction",
    "href": "03_data_wrangling/index.html#introduction",
    "title": "3  Wrangling data",
    "section": "3.1 Introduction",
    "text": "3.1 Introduction\nA major step in using any data to make decisions or draw conclusions is data wrangling: the process of transforming data from the format in which we originally have it to the format needed to analyse and present it to our audience.\n\n\n\nStart off by watching this video that walks through the different steps in wrangling a dataset. We will cover all the steps in the video in more detail during the rest of this tutorial.\n\n\n3.1.1 Functions\nIn this tutorial we will learn how to wrangle data in R using functions – specialised pieces of code that do something to the data we give it. The code to use a function (sometimes called calling the function) has two parts: the function name followed by a pair of parentheses, inside which are zero or more arguments separated by commas. Arguments are a way of providing input that a function works on, or to fine-tune the way the function works (we will see many examples of this later). Remember that you can identify a function in R because the name will always have parentheses after it.\nOne basic R function is sqrt(), which calculates the square root of a number. The sqrt() function has only one argument: the number that we want to find the square root of.\nsqrt(2)\nWhen you run code in R, by default R prints the output of your code – in this case, just the number 1.414214.\n\n\n3.1.2 Packages\n\n\n\nR contains thousands of different functions that do different things. A few functions are contained in the default installation of R that you have already installed (this is sometimes referred to as base R). But most functions are contained in packages, which are extensions to base R. Most packages focus on a particular type of data analysis, so that there are packages devoted to time-series analysis, testing whether events are clustered in particular places, network analysis and thousands of other tasks. Packages are often developed by experts in the field, and are typically updated to introduce new features.\nTo use a package in R, we must do two things:\n\ninstall the package, which we have to do just once on each computer we want to use, then\nload the package, which we have to do each time we restart R (which happens when we open RStudio or switch between projects).\n\nThe install.packages() function downloads and installs packages from the Comprehensive R Archive Network (universally known as CRAN), which contains about 19,000 different packages. Some packages that are still in the early stages of development are not available on CRAN, but all the packages we will use are there.\n\nSo to install (for example) the package called tidyverse, which we will use extensively in this tutorial, we would run the R code:\ninstall.packages(\"tidyverse\")\nWe only have to install a package once for each computer that we will use to run R, although we would have to do it again if we updated to a new version of R. Once a package is installed on our computer, we have to load it so that we can use it in our code. We load packages using the library() function, which should probably have been called load_package() but isn’t. So to load the tidyverse package, we run the code:\nlibrary(tidyverse)\nMany packages are focused on specialist tasks and so are only used occasionally, but a few packages are likely to be useful in almost all the code we write. Fortunately, packages can themselves load other packages, and all the main packages we need are themselves loaded by the tidyverse package. That is why you will often see library(tidyverse) at the top of R code in subsequent tutorials – that short line of code loads several packages containing hundreds of functions that we can use in data analysis.\n\nStats Illustrations by Allison Horst licensed under the Creative Commons Attribution licence."
  },
  {
    "objectID": "03_data_wrangling/index.html#loading-data",
    "href": "03_data_wrangling/index.html#loading-data",
    "title": "3  Wrangling data",
    "section": "3.2 Loading data",
    "text": "3.2 Loading data\nBefore we can do anything with any data, we have to load it into R. In this course we will read tabular data in comma-separated values (CSV) and Excel formats, as well as spatial data in different formats (because there are lots of ways to store spatial data). We will learn how to read CSV and Excel data now, but leave loading spatial data until later.\nTabular data contains multiple columns where every column has the same number of rows. For example, crime data might have columns for the type of crime, date and address at which the crime occurred.\n\n\n\nCrime data in rectangular format\n\n\ntype\ndate\naddress\n\n\n\n\nhomicide\n26 Jan 2022\n274 Main St\n\n\nnon-residential burglary\n05 Sep 2022\n541 Station Rd\n\n\npersonal robbery\n08 Jan 2023\n10 North Av\n\n\n\n\n\n\n3.2.1 Loading CSV data\n\nData stored in CSV format is easy to load with the read_csv() function from the readr package. readr is one of the packages loaded by the tidyverse package, so all we need to do to use this package is include the code library(tidyverse) on the first line of our R script. We will use comments (lines of code beginning with #) to help explain as we go.\n# Load the tidyverse suite of packages, including the readr package \n# that contains the read_csv() function\nlibrary(tidyverse)\n\n# We can load data from a file in the same folder as our R script\nsan_fran_rob <- read_csv(\"san_francisco_robbery.csv\")\n\n# Or another folder on your computer ('../' is short for the parent \n# folder of the current folder)\nsan_fran_rob <- read_csv(\"../san_francisco_robbery.csv\")\n\n# Or directly from a file online\nsan_fran_rob <- read_csv(\"http://example.com/san_francisco_robbery.csv\")\nIn each of these examples, the code stores the result of the read_csv() function in an object named san_fran_rob. Objects are places where we can store data. To create an object and store our data in it, we use the assignment operator <- (a less-than sign followed by a dash). Continually typing <- can be tedious, so in RStudio we can use the keyboard short cut Option+- (on Mac) or Alt+- (on Windows or Linux) to insert the complete operator.\n\nWhen choosing object names, it is important to remember that if you assign a value (such as the number 1 or the result of the function read_csv()) to an object name, R will overwrite any existing value of that object name. We can see this in a simple example:\none_to_ten <- 1:10\none_to_ten <- sqrt(2)\nIf we were to run this code, the object one_to_ten would not actually hold the numbers from one to ten, but instead the value 1.414214 (the square root of two). There is also no way to undo assignment of a value to an object, so once you have run the code one_to_ten <- sqrt(2) it is not possible to recover any previous value that was assigned to the object one_to_ten.\n\nObjects come in several different types, with tabular data typically being stored as a data frame. The read_csv() function actually produces a modern variation on the data frame called (slightly strangely) a tibble, which makes use of some advances in how R handles data since the data-frame format was set 20 years ago. Tibbles behave just like data frames almost all of the time (so much so that people working with tibbles often call them data frames) except for a few occasions where they behave in a more-convenient way.\nWe can read_csv() to load data from https://github.com/mpjashby/crimemapping/raw/main/inst/extdata/san_francisco_robbery.csv and store it in an object called san_fran_rob.\nsan_fran_rob <- read_csv(\"https://github.com/mpjashby/crimemapping/raw/main/inst/extdata/san_francisco_robbery.csv\")\nIf the data are loaded successfully, R will list the columns in the data and the type of variable (numeric, date etc.) stored in each column. The format of this is somewhat esoteric, but if you are interested they are explained in the ‘Extra detail’ box below.\n\n\nWhat do the messages produced by read_csv() mean?\n\n\nBy default, the read_csv() function prints a message when it loads data to summarise the format of each data column. In the case of the san_fran_rob dataset, read_csv() tells us that:\n\nthere is one column called offense_type that contains character (chr) values,\nthere are three columns called uid, longitude and latitude containing numeric (dbl) values, and\nthere is one column called date_time that contains values stored as dates and times (dttm).\n\nThere are some other possible types of data, but we will learn about these later on. The numeric values are referred to as dbl values because they are stored in a format that can handle numbers that are not whole numbers (e.g. 123.456). This format for storing numbers is called the double-precision floating-point format, which is often known as the double format for short. Most numbers in R are stored in double format, so you can think of the format code dbl as meaning ‘numeric’.\n\n\n\nTo see the first few rows of data currently stored in an object, we can use the head() function.\nhead(san_fran_rob)\n\n\n3.2.2 Loading Excel data\n\nLoading data from Microsoft Excel files is very similar to loading CSV data, with a few important differences. Functions to load Excel data are contained in the readxl package, which was installed automatically when we installed the tidyverse package.\nThere are two main things we must do to import Excel data that are not required for importing CSV data. The first is that the readxl package cannot directly load files from a URL, instead only loading files that are present on your computer. To get round this, we will first download an Excel file and store it in a temporary directory (to avoid cluttering up our computers).\n\nUsing download.file() on Windows\nIf you are using a Windows computer, you may find that the download.file() function in the code below does not work as expected. This is because Windows handles files in a way that distinguishes between plain-text files such as .txt and .csv files and binary files, which includes most other file types (including compressed files). Since aggravated_assaults.xlsx is not a plain-text file, on Windows you need to specify that you want it to be downloaded as a binary file. To do this, add the argument mode = \"wb\" to the download.file() function so that it reads:\ndownload.file(\n  url = \"https://github.com/mpjashby/crimemapping/raw/main/inst/extdata/aggravated_assaults.xlsx\",\n  destfile = temp_file,\n  mode = \"wb\"\n)\nIf you are using a Mac or a Linux computer then you do not need to worry about this.\n\n# Specify the name of and location of our temporary file: it does not matter\n# what this file is called or where it is stored, so we use the tempfile()\n# function to create a file in the correct location automatically\ntemp_file <- tempfile(fileext = \".xlsx\")\n\n# Download the Excel file and store it in the temporary location\ndownload.file(\n  url = \"https://github.com/mpjashby/crimemapping/raw/main/inst/extdata/aggravated_assaults.xlsx\",\n  destfile = temp_file,\n  mode = \"wb\"\n)\nThe download.file() function does not produce any output if the file has been successfully downloaded, so you will not see any output when you run this code.\nNow we have downloaded our data, we can load it into R. Since Excel files can contain multiple sheets, we need to specify which sheet we would like to load into a tibble. We can use the excel_sheets() function to get a list of sheets in an Excel file:\n# Load the readxl package\nlibrary(readxl)\n\n# Get a list of sheets in an Excel file\nexcel_sheets(temp_file)\nWe can now load the sheet containing data for Austin and view the first few rows of the resulting object:\nagg_assault_data <- read_excel(temp_file, sheet = \"Austin\")\n\nhead(agg_assault_data)\nNow we have learned how to load our data into an object, we can use other R functions to work with that data in many different ways.\n\nLearn more about how to read data into R by reading this chapter of the free online book R for Data Science.\nExcel data can often be messy and the readxl package contains various other functions that can be used to deal with this. You can learn more about how to handle messy Excel data in this online tutorial."
  },
  {
    "objectID": "03_data_wrangling/index.html#selecting-columns",
    "href": "03_data_wrangling/index.html#selecting-columns",
    "title": "3  Wrangling data",
    "section": "3.3 Selecting columns",
    "text": "3.3 Selecting columns\nIn this section we will learn how to reduce the size of our data by selecting only the columns we need and discarding the rest. This can be particularly useful if we are working with a very-large dataset, or if we want to produce a table containing only some columns.\n\n\n\nWe can use the select() function from the dplyr package (one of the packages that is loaded automatically when we call the library(tidyverse) function) to select columns.\nIf we wanted to select just the date and location_type columns from the agg_assault_data we loaded in the previous section:\nselect(agg_assault_data, date, location_type)\n\nIn a previous section, we mentioned that the code needed to run (or call) a function in R has two parts: the function name followed by a pair of parentheses, inside which are zero or more arguments separated by commas. The arguments in the select() function (and many other functions in the dplyr package) work in a slightly different way to many other functions. Here, the first argument is the name of the data object that we want to select from. All the remaining arguments (here, date and location_type) are the names of the columns we want to select from the data.\nWe can select as many columns as we want, by just adding the names of the columns separated by commas. Write the code necessary to select the longitude and latitude columns from the agg_assault_data object:\nselect(agg_assault_data, longitude, latitude)\nThe columns in our new dataset will appear in the order in which we specify them in the select() function.\nWe can also use select() to rename columns at the same time as selecting them. For example, to select the columns date and location_type while also renaming location_type to be called type:\nselect(agg_assault_data, date, type = location_type)\nIf we want to rename a column while keeping all the columns in the data, we can instead use the rename() function (also from the dplyr package):\nrename(agg_assault_data, type = location_type)\nRemember that functions in R generally do not change existing objects, but instead produce (or return) new ones. This means if we want to store the result of this function so we can use it later, we have to assign the value returned by the function to a new object (or overwrite the existing object):\nagg_assault_locations <- select(agg_assault_data, lon = longitude, lat = latitude)\n\nhead(agg_assault_locations)\n\nYou can learn more about selecting, filtering and arranging data using the functions in the dplyr package by reading this Introduction to dplyr tutorial."
  },
  {
    "objectID": "03_data_wrangling/index.html#filtering-rows",
    "href": "03_data_wrangling/index.html#filtering-rows",
    "title": "3  Wrangling data",
    "section": "3.4 Filtering rows",
    "text": "3.4 Filtering rows\nOften in crime mapping we will only be interested in part of a particular dataset. In the same way that we can select particular columns in our data, we can filter particular rows using the filter() function from the dplyr package.\n\n\n\nIf we were only interested in offences in the agg_assault_data dataset that occurred in residences, we could use filter():\nfilter(agg_assault_data, location_type == \"residence\")\nNote that:\n\nthe column name location_type is not surrounded by quotes but the column value \"residence\" is, and\nthe == (equal to) operator is used, since a single equals sign = has another meaning in R.\n\nWe can filter using the values of more than one column simultaneously. To filter offences in which the location_category is ‘leisure’ and the location_type is ‘bar/club’:\nfilter(\n  agg_assault_data, \n  location_category == \"leisure\", \n  location_type == \"bar/club\"\n)\nAs well as filtering using the == operator, we can filter using the greater-than (>), less-than (<), greater-than-or-equal-to (>=) and less-than-or-equal-to (<=) operators. For example, we can choose offences that occurred in residences on or after 1 July 2019:\nfilter(\n  agg_assault_data, \n  location_type == \"residence\", \n  date >= as.Date(\"2019-07-01\")\n)\nSometimes we will want to filter rows that are one thing or another. We can do this with the | (or) operator. For example, we can filter offences that occurred either in leisure facilities or shopping malls on or after 1 July 2019:\nfilter(\n  agg_assault_data, \n  location_category == \"leisure\" | location_type == \"mall\", \n  date >= as.Date(\"2019-07-01\")\n)\nIf we want to filter offences that have any one of several different values of the same column, we can use the %in% (in) operator. To filter offences that occurred in either streets or publicly accessible open spaces:\nfilter(agg_assault_data, location_category %in% c(\"open space\", \"street\"))\nThe code c(\"open space\", \"street\") produces what is referred to in R as a vector (sometimes referred to as an atomic vector, especially in error messages). A vector is a one-dimensional sequence of values of the same type (i.e. all numbers, all character strings etc.). For example, a vector might hold several strings of text (as in the vector c(\"open space\", \"street\")) or a series of numbers such as c(1, 2, 3). There is lots we could learn about vectors, but for now it’s only necessary to know that we can create vectors with the c() or combine function.\nIf we wanted to re-use a vector of values several times in our code, it might make sense to store the vector as an object. For example:\n# Create vector of location types we are interested in\nlocation_types <- c(\"open space\", \"street\")\n\n# Filter the data\nfilter(agg_assault_data, location_category %in% location_types)\nFinally, you can filter based on the output of any R function that returns TRUE or FALSE. For example, missing values are represented in R as NA. We can test whether a value is missing using the is.na() function. If we wanted to remove rows from our data that had missing location types, we would filter for those rows that are not NA. We can do this by combining the is.na() function with the ! (not) operator:\nfilter(agg_assault_data, !is.na(location_type))\nWe will see lots more examples of how to use filter() in future tutorials.\n\nStats Illustrations by Allison Horst licensed under the Creative Commons Attribution licence."
  },
  {
    "objectID": "03_data_wrangling/index.html#transforming-values",
    "href": "03_data_wrangling/index.html#transforming-values",
    "title": "3  Wrangling data",
    "section": "3.5 Transforming values",
    "text": "3.5 Transforming values\nIt is often useful to create new columns in our data, or change the values of existing columns. The mutate() function in the dplyr package gives us a way to transform existing columns in our dataset using almost any R function.\n\n\n\n\nFor example, say we wanted to create a new column in our aggravated-assault dataset specifying the day of the week on which each crime occurred. We can do this using the wday() function from the lubridate package (using the label = TRUE argument to produce weekday names, rather than numbers):\nlibrary(lubridate)\n\nmutate(agg_assault_data, weekday = wday(date, label = TRUE))\nDepending on the width of your screen, you might need to click the ▸ button to see the new variable.\nWe can also categorise an existing variable, for example creating a variable to show whether an offence occurred in the northern or southern half of the city:\nmutate(\n  agg_assault_data, \n  region = if_else(latitude > median(latitude), \"northern\", \"southern\")\n)\nWe can change existing columns, although (as with objects) there is no way to undo this so you should only replace columns if you are sure you will not need them. For example, if we wanted to remove the time portion of the date variable (which may sometimes be useful, as shown in the next section) using the as_date() function (also from the lubridate package) and at the same time create the weekday variable:\nmutate(\n  agg_assault_data, \n  date = as_date(date),\n  weekday = wday(date, label = TRUE)\n)\nYou may sometimes want to change only some values in a column. We can do this in various ways, depending on which values we want to change:\nmutate(\n  agg_assault_data,\n  # Change a single value with a new value (and otherwise keep the existing \n  # value) using the if_else() function\n  location_type = if_else(location_type == \"street\", \"road\", location_type),\n  # Change multiple values in a categorical variable using the recode() \n  # function, in which values are changed using arguments in the format\n  # old_value = new_value\n  location_category = recode(\n    location_category, \n    \"open space\" = \"public open space\",\n    \"street\" = \"street or road\"\n  )\n)\nWe could also make changes based on more-complicated sets of criteria using the case_when() function, but we will return to that in a future tutorial.\nThe R functions that you use inside mutate() must return the same number of values as there are rows in the dataset. This is true for most R functions (which are referred to as vectorised functions), but there are some – such as mean() and max() – that return a single value. These summarising functions cannot be used inside mutate() (you will see an error message if you try) but are instead used with the next data-wrangling function we will learn about: summarise().\n\nStats Illustrations by Allison Horst licensed under the Creative Commons Attribution licence."
  },
  {
    "objectID": "03_data_wrangling/index.html#summarising-rows",
    "href": "03_data_wrangling/index.html#summarising-rows",
    "title": "3  Wrangling data",
    "section": "3.6 Summarising rows",
    "text": "3.6 Summarising rows\nSummarising data is often useful in crime analysis. We can use the summarise() function from the dplyr package to produce summaries of different columns in our data. There is an identical function called summarize() so that you do not have to remember whether to use the US or British spelling.\nBy default, summarise() collapses data into a single row, with each column summarised using a function that you specify. For example, suppose you want to find out which police station a specialist squad should be based at to most easily respond to reports of serious assaults. You might do this by working out the weighted centre of all the offence locations, i.e. the means of the longitudes and latitudes for all the crimes. You could then base the squad at the police station that was closest to the weighted centre.\nsummarise(\n  agg_assault_data, \n  mean_lng = mean(longitude, na.rm = TRUE),\n  mean_lat = mean(latitude, na.rm = TRUE)\n)\n\n\nWhat does the argument na.rm = TRUE do?\n\n\nLots of functions in R have an argument called na.rm that can be set to either TRUE or FALSE. Setting na.rm = TRUE in this case specifies that the mean() function should remove (rm) any missing (NA) values before calculating the mean.\nIf we do not specify this and our data contain any missing values, the mean() function will return NA. Functions in R do this because it is not possible to completely answer the question ‘what is the mean of these values?’ if some of the values are missing.\nThis logic applies in lots of cases. For example, if you create an R object called value with the code value <- 2 and then run the R code value > 1, you will get the answer TRUE. But if you set the object value to be NA using the code value <- NA, when you run the R code value > 1 you will get the answer NA. This is because there is no way to know if the missing value represented by NA is greater than 1 or not. This is why it is often useful to calculate statistics such as a mean value after removing any missing values using the na.rm = TRUE argument.\n\n\n\nsummarise() becomes more useful if we first divide our data into groups, since we then get a summary for each group separately. We can use the group_by() function to specify which columns denote which group each row is in. So if we wanted to repeat the calculation above, but separately for each value of location_category:\nsummarise(\n  group_by(agg_assault_data, location_category),\n  mean_lng = mean(longitude, na.rm = TRUE),\n  mean_lat = mean(latitude, na.rm = TRUE)\n)\nThis code might be slightly difficult to read, since the group_by() function is called inside summarise(), but we will learn a way of writing this code that might be easier to read in the final section of this tutorial.\nYou can add multiple grouping variables if you want to generate summary values for groups within groups:\nsummarise(\n  group_by(agg_assault_data, location_category, location_type),\n  mean_lng = mean(longitude, na.rm = TRUE),\n  mean_lat = mean(latitude, na.rm = TRUE)\n)\n\n\nDid you see a message saying `summarise()` has grouped output by 'location_category'?\n\n\nYou might have noticed the that code above produced a message specifying how groups have been handled by summarise(). This message reminds you that by default the summarise() functions strips the final level of grouping added by group_by(). This allows us to summarise data using a detailed set of groups and then summarise those summaries using more-general groups. In practice, this ability has been a source of some confusion, so R now prints a message to remind you that the data are still grouped after you run summarise(). If you want to hide this message then you can add .groups = \"drop\" to the summarise() function to remove all the groups in the data.\n\n\n\n\n3.6.1 Counting rows\nOne form of summarising grouped data is so common that it gets its own function: count(). This simply counts the number of rows of data in each group. So if you wanted to know how many aggravated assaults had occurred in each location category and type:\ncount(group_by(agg_assault_data, location_category, location_type), sort = TRUE)\nThe sort = TRUE argument sorts the counts in descending order. You can do more-sophisticated sorting using the arrange() function, which we will learn about in the next section."
  },
  {
    "objectID": "03_data_wrangling/index.html#arranging-rows",
    "href": "03_data_wrangling/index.html#arranging-rows",
    "title": "3  Wrangling data",
    "section": "3.7 Arranging rows",
    "text": "3.7 Arranging rows\nIt is sometimes useful to be able to place rows in a dataset into a particular order. We can do this using the arrange() function from the dplyr package. For example, we can sort the aggravated-assault data by date:\narrange(agg_assault_data, date)\nBy default, arrange() sorts rows in ascending order, i.e. it sorts numeric values from the smallest to the largest, dates from earliest to latest and character values alphabetically. We can instead sort values in descending order by wrapping the name of a column in the desc() function:\narrange(agg_assault_data, desc(date))\nWe can also sort the data based on multiple columns – the data are sorted first on the first column that you specify, with tied rows then sorted on the subsequent columns in order.\narrange(agg_assault_data, date, desc(location_type), location_category)\n\n3.7.1 Check your understanding\nType the code necessary to arrange agg_assault_data in order of latitude, in descending order (from largest to smallest)\nRun your code using the Run Code button, then (if necessary) correct your code and run it again. Once you are happy that your code does what it is intended to do, click the Solution button to check.\narrange(agg_assault_data, desc(latitude))"
  },
  {
    "objectID": "03_data_wrangling/index.html#saving-data",
    "href": "03_data_wrangling/index.html#saving-data",
    "title": "3  Wrangling data",
    "section": "3.8 Saving data",
    "text": "3.8 Saving data\nOnce we have finished wrangling a particular dataset, it is often useful to save it to a file so that we can use it again in future without going through all the steps of data wrangling again.\nMost R functions that begin with read_ (like read_csv() and read_excel()) have equivalent functions that begin write_ and which save data into a particular file format. In this example, we will use the write_csv() function from the readr package, which is loaded when we load the tidyverse package.\n# We can write data to a file in the same folder as our R script\nwrite_csv(agg_assault_data, \"fort_worth_agg_assault.csv\")\n\n# Or another folder on your computer ('../../' is short for the parent folder of\n# the parent folder of the current folder)\nwrite_csv(agg_assault_data, \"../../fort_worth_agg_assault.csv\")\nFor very large datasets, we can save a compressed version of the file by adding .gz (for gzip) to the end of the file name, which tells R to compress the file after creating it.\nwrite_csv(agg_assault_data, \"fort_worth_agg_assault.csv.gz\")\nread_csv() can read gzipped CSV files, but some other programs (such as Excel) cannot, so only use this option if you are sure you will only need to open the file in software that can handle it.\nThere are corresponding write functions for other types of data (which we will come back to when we learn how to handle spatial data), but in this course we will store all non-spatial data in CSV format because it can be read by many different programs."
  },
  {
    "objectID": "03_data_wrangling/index.html#stringing-functions-together",
    "href": "03_data_wrangling/index.html#stringing-functions-together",
    "title": "3  Wrangling data",
    "section": "3.9 Stringing functions together",
    "text": "3.9 Stringing functions together\nIn this tutorial we have learned how to use the dplyr functions select(), filter(), mutate(), summarise() and arrange() to wrangle data from one format to another. Data wrangling is part of almost all data analysis, so these are skills we will use frequently.\nData wrangling often involves multiple steps. For example, we might want to load some data, select certain columns, filter some rows, mutate some of the variables, summarise the dataset and save the result. We can do each of these steps separately, assigning the result of each step to a new object.\n# Load the lubridate package, since we will need it below\nlibrary(lubridate)\n\n# Read San Francisco robbery data\nrobbery1 <- read_csv(\"https://github.com/mpjashby/crimemapping/raw/main/inst/extdata/san_francisco_robbery.csv\")\n\n# Select only the columns we need\nrobbery2 <- select(robbery1, date_time)\n\n# Filter only those offences that occurred in the first quarter of 2019\nrobbery3 <- filter(robbery2, as.Date(date_time) <= as.Date(\"2019-03-31\"))\n\n# Create a new weekday variable\nrobbery4 <- mutate(robbery3, weekday = wday(date_time, label = TRUE))\n\n# Count how many offences occurred on each weekday\nq1_weekday_counts <- count(robbery4, weekday)\n\n# Print the first few rows of the result\nhead(q1_weekday_counts, n = 7)\nThis code works, but involves creating six new objects, even though we only need the final object for our analysis. You may notice that the first argument expected by select(), filter(), mutate() and count() is always the data tibble produced by the previous step. This means we can skip saving the result of each step as a new object, and just run the previous function inside the first function. This approach produces the following code, which produces exactly the same result as the code above.\nq1_weekday_counts <- count(\n  mutate(\n    filter(\n      select(\n        read_csv(\"https://github.com/mpjashby/crimemapping/raw/main/inst/extdata/san_francisco_robbery.csv\"),\n        -offense_type\n      ), \n      as.Date(date_time) <= as.Date(\"2019-03-31\")\n    ),\n    weekday = wday(date_time, label = TRUE)\n  )\n)\n\nhead(q1_weekday_counts, n = 7)\nThis code works and takes up less space, but it’s quite difficult to read – which can be a problem for finding and fixing problems with your code. For example, it’s quite hard (without counting pairs of parentheses) to work out that the reference to the column weekday on line 13 of this code belongs to the group_by() function on line 2.\nIt’s possible to write this code so that it is readable and does not require us to create multiple different objects to store the result of each step in our code. This method uses the |> (or pipe) operator. The pipe operator works by using the result of the code on the left-hand side of the pipe as the first argument to a function on the right-hand side. So the code x  |> fun1()  |> fun2(y) is the same as the code fun2(fun1(x), y), but it is much easier to see that fun1() is run before fun2(). It may be useful to read the pipe operator as ‘and then’, since piped code does the first thing and then the second thing with the result and then the third thing with the result of that, and so on. Piped code (sometimes called a pipeline) is a lot like the series of steps in a recipe.\nSince each function we are using returns the new data, and the first argument to all of those functions is the name of the input data object, the pipe means we can just omit the first argument to all except the first function.\nsan_fran_rob <- read_csv(\"https://github.com/mpjashby/crimemapping/raw/main/inst/extdata/san_francisco_robbery.csv\")\n\nq1_weekday_counts <- san_fran_rob |> \n  select(-offense_type) |> \n  filter(as.Date(date_time) <= as.Date(\"2019-03-31\")) |> \n  mutate(weekday = wday(date_time, label = TRUE)) |> \n  count(weekday)\n\nhead(q1_weekday_counts, n = 7)\nThis code strikes a good balance between being easy to read and not requiring us to manage lots of intermediate variables. You might not find the pipe operator completely intuitive at the moment, but it will become easier as you see more examples in future tutorials.\n\n\nWhat about the %>% pipe operator?\n\n\nIf you have learned any R coding before, you might have learned to use the %>% pipe operator from the magrittr package. The %>% pipe operator was introduced several years ago to allow people to construct pipelines of code in R. The %>% operator was so widely used that the team that writes the R programming language decided to provide a pipe operator in R itself, to avoid the need to load the magrittr package.\nYou will still see the %>% pipe operator used in lots of R code examples online. In almost all cases, when you see %>% you can replace it with the R pipe operator |>, since they both work in very similar ways.\n\n\n\n\nYou can find out more about how to use the pipe operator in the Introducing magrittr online tutorial."
  },
  {
    "objectID": "03_data_wrangling/index.html#in-summary",
    "href": "03_data_wrangling/index.html#in-summary",
    "title": "3  Wrangling data",
    "section": "3.10 In summary",
    "text": "3.10 In summary\n\nIn this tutorial, you have learned how to wrangle data in R using functions from packages in the tidyverse suite of packages. You can now construct a complete pipeline of R code to take raw data and transform it into the format(s) we need to effectively map crimes.\n\n\nDeveloping your data wrangling skills will help you to produce better, faster analysis of crime (and other) data. If you would like to develop your skills further, you might be interested in:\n\nData Wrangling with R by Claudia Engel, a free online book that explains the functions introduced in this tutorial (and some others) in more detail.\nData transformation with dplyr cheat sheet by the team that makes RStudio, which provides a handy two-page guide to the main functions in the dplyr package, which is very useful for reminding you of the code needed to run each of the functions we have used in this tutorial.\nData wrangling with R and RStudio by Garrett Grolemund, a recording of a webinar covering the data-wrangling functions introduced in this tutorial and some other very-useful related functions.\nR for Data Science by Hadley Wickham and Garrett Grolemund, a free online book that is the bible for wrangling data in R."
  },
  {
    "objectID": "04_code_with_style/index.html#introduction",
    "href": "04_code_with_style/index.html#introduction",
    "title": "4  Code with style",
    "section": "4.1 Introduction",
    "text": "4.1 Introduction\nNow that you’re beginning to write code in R, it’s time to introduce a few conventions for how to write code so that it’s easier to read. This is important because “good coding style is like correct punctuation: you can manage without it, butitsuremakesthingseasiertoread”.\nWriting readable code is particularly important because it is much easier to find mistakes in well-written code, and your code will inevitably contain mistakes (everyone’s code contains mistakes!).\nWriting code has been compared to performing in a band:\n\nI liken the situation to a group of musicians trying to form a band. Each one comes in believing that their way of doing things is best (their “method” or “process”). The band will struggle so long as everyone is trying to do their own thing. It’s impossible to create good music unless everyone in the band agrees on the tempo, the style and who should take lead during a song. Anyone who has ever heard a high school band perform knows this to be true. Unless everyone is on the same page, you aren’t going to accomplish much.\n\nYou might be relaxing at this point, thinking “that isn’t a problem for me, because I’m the only person who is going to be working on my code”. If so, think again. It’s been said that in data science that there are always at least two people working on a project: the you who is working on the code now, and the past you who has worked on the same code previously. The problem is that past you does not answer emails. So you can save future you a lot of hassle later by writing readable code.\nThis tutorial introduces some basic guidelines on formatting your code. This is a condensed version of the The tidyverse style guide, which provides lots more detail. All the code you see in the tutorials in this course was written following this style guide.\n\n\n\n\nOn Perl from Three Panel Soul. Some content on this page contains public sector information licensed under the Open Government Licence v3."
  },
  {
    "objectID": "04_code_with_style/index.html#organising-your-code",
    "href": "04_code_with_style/index.html#organising-your-code",
    "title": "4  Code with style",
    "section": "4.2 Organising your code",
    "text": "4.2 Organising your code\nUp until now we have only written code in the code boxes within these interactive tutorials, but when you move on to make maps using your own R code you will typically write that code in the RStudio source panel. Your code will usually be in one or more files with the .R file extension. Whether you keep all your code for a specific project in one file or split it into multiple files is up to you. Generally you should do whatever makes it easier to understand how your code is structured.\n\n4.2.1 Leaving notes for future you\nWithin each .R file, you can make your code easier to understand in several ways. First, add a comment (one or more lines beginning with # followed by a space) at the top of the file to explain what the code in that file does. This will make it easier for you to know that you’ve found the right file if you are looking for it in a few weeks when you’ve forgotten (which you will) what file contains what code.\n# This code produces a density map of bike thefts in Vancouver in 2020\nComments should usually start with a capital letter and follow normal English rules of punctuation, spacing, etc.\n\n\n4.2.2 Letting your code breathe\nUnless your code is very simple, it will probably consist of several separate tasks that are completed one after another. For example your code might download some data, wrangle it and then plot it on a map. In that case, it can be useful to split your code up into blocks by leaving a blank line between the code needed for each task. For example, if we take the code:\nlibrary(lubridate)\nlibrary(tidyverse)\ncrimes <- read_csv(\"crime_data.csv\")\ncrimes <- janitor::clean_names(crimes)\nburglaries <- filter(crimes, type == \"burglary\")\nburglaries <- mutate(burglaries, month = month(date_time))\nggplot() + \n  geom_point(aes(x = lon, y = lat, colour = month)) +\n  theme_void()\nit becomes easier to read if we split the code up into four tasks: loading the necessary packages, reading the data, wrangling the data and plotting the data.\nlibrary(lubridate)\nlibrary(tidyverse)\n\ncrimes <- read_csv(\"crime_data.csv\")\n\ncrimes <- janitor::clean_names(crimes)\nburglaries <- filter(crimes, type == \"burglary\")\nburglaries <- mutate(burglaries, month = month(date_time))\n\nggplot() + \n  geom_point(aes(x = lon, y = lat, colour = month)) +\n  theme_void()\nSince data wrangling involves several steps and each function uses the result of the previous step, we could use the pipe operator |> to make that code a bit cleaner:\nlibrary(lubridate)\nlibrary(tidyverse)\n\ncrimes <- read_csv(\"crime_data.csv\")\n\nburglaries <- crimes |> \n  janitor::clean_names() |> \n  filter(type == \"burglary\") |> \n  mutate(month = month(date_time))\n\nggplot() + \n  geom_point(aes(x = lon, y = lat, colour = month)) +\n  theme_void()\n\n\n4.2.3 Header comments\nIf your code includes very long tasks (e.g. where the code takes up more than a full screen on your computer), you might want to use header comments to divide your code into sections. You can do this by writing a comment that is followed by four of more hyphens (----):\n# Load data ----\n\n… some code …\n\n\n# Wrangle data ----\n\n… some code …\n\n\n# Plot data ----\n\n… some code …\nRStudio will recognise lines that end in four or more hyphens as being headings, and will create a table of contents for your code. You can use this to move between headings by clicking on the Jump To menu at the bottom of the Source panel in RStudio:\n\n\n\n\n\n\n\n\n\nIn general, writing code that is readable is more important than writing the shortest code possible, so don’t be afraid to let your code breathe by using space to separate your code into meaningful chunks."
  },
  {
    "objectID": "04_code_with_style/index.html#naming-objects",
    "href": "04_code_with_style/index.html#naming-objects",
    "title": "4  Code with style",
    "section": "4.3 Naming objects",
    "text": "4.3 Naming objects\nR objects can have any name you like, as long as the name starts with a letter and contains only letters, numbers, dots (.) and underscores (_). That said, you will find coding easier if you follow a few conventions.\n\nUse only lower-case letters in the names of objects, which avoids you having to remember whether a particular letter was upper- or lower-case.\nUse snake case (object_name, with words separated by underscores) for object names rather than camel case (objectName) or kebab case (object-name).\nDon’t use dots in object names.\nDon’t give objects the same names as R functions, because re-using function names makes reading your code more difficult.\n\n\n\n\n\n\n\n\n\n\nJust as crime_data_atlanta_2020.csv is a more-useful file name than data_file_23.csv, you will find it easier to read your code if you give your objects meaningful names. So when you load data into R (e.g. with read_csv()) don’t just call it data (not least because there is a function named data()) but instead give it a name like atlanta_crimes if it contains (for example) crime data from Atlanta.\n\nStats Illustrations by Allison Horst licensed under the Creative Commons Attribution licence."
  },
  {
    "objectID": "04_code_with_style/index.html#spacing",
    "href": "04_code_with_style/index.html#spacing",
    "title": "4  Code with style",
    "section": "4.4 Spacing",
    "text": "4.4 Spacing\nSpacing out code makes it much easier to read, but (just as in any language) code is easiest to read if spaces are used where people expect them to be by convention.\nMostly in R, we use spaces where we would expect them in English: after commas but not before, outside parentheses but not inside, etc.\n# Good\nread_csv(\"crime_data.csv\", skip = 4)\n\n# Bad\nread_csv(\"crime_data.csv\",skip = 4)\nread_csv(\"crime_data.csv\" ,skip = 4)\nread_csv(\"crime_data.csv\" , skip = 4)\nDon’t put spaces inside parentheses, or between the names of functions and the parentheses:\n# Good\nmean(x, na.rm = TRUE)\n\n# Bad\nmean (x, na.rm = TRUE)\nmean( x, na.rm = TRUE )\nDo put spaces around most operators (==, +, -, <-, etc.), including either side of = when specifying the values of function arguments:\n# Good\nheight <- (feet * 12) + inches\nmean(x, na.rm = TRUE)\n\n# Bad\nheight<-feet*12+inches\nmean(x, na.rm=TRUE)\nAlthough there are some operators that shouldn’t have spaces around them: $, @, [, [[, ^, : and ?."
  },
  {
    "objectID": "04_code_with_style/index.html#functions",
    "href": "04_code_with_style/index.html#functions",
    "title": "4  Code with style",
    "section": "4.5 Functions",
    "text": "4.5 Functions\nWe’ve now got used to calling functions to do things in R, like calling read_csv() to load data from a CSV file or filter() to choose certain rows from a dataset. We know that we can change the behaviour of functions by using arguments. For example, we can wrap a a string of text into shorter lines using the str_wrap() function from the stringr package. str_wrap() needs two arguments: the text to be wrapped into multiple lines and the maximum length of a line of text before the next word is wrapped onto a new line. These arguments are called string and width, so we can call the function as:\nstr_wrap(string = \"some text to be wrapped\", width = 10)\nThe string argument provides the data that the str_wrap() function will work on, while the width argument provides the details of how that work should be done. Since the data argument to a function is typically required (the function makes no sense without it) and is often the first argument, you can omit the name of data arguments to functions. For all other arguments, it is best to give the argument name. So to use str_wrap(), you can write:\nstr_wrap(\"some text to be wrapped\", width = 10)\nIn general, you should keep lines of code to a maximum of 80 characters long, since they can easily fit on most screens and are easy to read. When calling a function, put all of the parameters on a single line if they will fit into 80 characters or less:\ndo_something_simple(\"something\", with = \"only\", short, \"arguments\")\nBut if the function call is longer than 80 characters, use one line each for the function name, each argument, and the closing ), with the arguments indented by two spaces. This makes the code much easier to read.\n# Good\ndo_something_very_complicated(\n  something = \"that\",\n  requires = many,\n  arguments = \"some of which may be long\"\n)\n\n# Bad\ndo_something_very_complicated(\"that\", requires, many, arguments,\n                              \"some of which may be long\"\n                              )\ndo_something_very_complicated(\n  something = \"that\",\n  requires = many,\n  arguments = \"some of which may be long\")\nWhen combining multiple functions using the pipe operator (|>), put each function on a single line, with all but the first line indented by two spaces:\na_function() |> \n  another_function() |> \n  and_a_third_function()\nOnce you learn about other types of R code you will need to know how best to style it, but we will learn about those when we need to."
  },
  {
    "objectID": "04_code_with_style/index.html#styling-your-code-automatically",
    "href": "04_code_with_style/index.html#styling-your-code-automatically",
    "title": "4  Code with style",
    "section": "4.6 Styling your code automatically",
    "text": "4.6 Styling your code automatically\nYou can get help on styling your R code using the styler package, which can automatically format your code for you. After you install the styler package with the code install.packages(\"styler\"), you can style your code by:\n\nselecting the code you want to style,\nopening the Addins menu at the top of the Source panel in RStudio,\nclicking ‘Style selection’ in the ‘Styler’ section of the list of addins.\n\n\n\n\n\n\n\n\n\n\nRStudio will also try to help style your code as you type, for example by automatically indenting lines."
  },
  {
    "objectID": "04_code_with_style/index.html#in-summary",
    "href": "04_code_with_style/index.html#in-summary",
    "title": "4  Code with style",
    "section": "4.7 In summary",
    "text": "4.7 In summary\n\nYou now know how to write your R code so that it is easy to read, which makes it much easier to understand. Understanding code when you read it is important because it allows you to work out what the code is trying to achieve and because it makes it much easier to find and fix problems when your code is not behaving as you want it to.\n\n\nWriting readable, understandable code is important. To find out more about this, read some of these articles:\n\nWhy coding style matters by Nicholas Zakas.\nThe tidyverse style guide by Hadley Wickham, which is the basis for the rules outlined in this tutorial.\n\n\n\nThe tidyverse style guide licensed under the Creative Commons Attribution-ShareAlike licence."
  }
]