[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Learn crime mapping with R",
    "section": "",
    "text": "Welcome!\nThis book will give you the knowledge and skills to effectively communicate information about crime and related topics using maps. We will cover the principles of analysing geographic information and the strengths and weaknesses of different maps for communicating it."
  },
  {
    "objectID": "index.html#who-is-this-book-for",
    "href": "index.html#who-is-this-book-for",
    "title": "Learn crime mapping with R",
    "section": "Who is this book for?",
    "text": "Who is this book for?\nThis book is for you if you are:\n\nSomeone who wants to learn how to understand patterns of crime using maps and related forms of data analysis.\nSomeone who already knows how to map crimes and would like to learn how to programme in a familiar context."
  },
  {
    "objectID": "index.html#why-use-this-book",
    "href": "index.html#why-use-this-book",
    "title": "Learn crime mapping with R",
    "section": "Why use this book?",
    "text": "Why use this book?\nThere are several books available for learning crime mapping. The advantages of using this book are that:\n\nIt teaches up-to-date crime mapping techniques. Some of the most-popular books on crime mapping were written over a decade ago and do not reflect substantial developments in the field since then.\nIt teaches crime mapping using exclusively free software (R and RStudio). Some other books teach crime mapping in expensive proprietary software that most people who need to make crime maps do not have access to.\nIt is an online book, so includes videos to introduce theoretical concepts and walk you through the process of creating different maps.\nIt uses examples from across the world, so it is not only useful to readers from one country.\nIt’s completely free to read and redistribute!"
  },
  {
    "objectID": "index.html#why-learn-crime-mapping-in-r",
    "href": "index.html#why-learn-crime-mapping-in-r",
    "title": "Learn crime mapping with R",
    "section": "Why learn crime mapping in R?",
    "text": "Why learn crime mapping in R?\nWe could make crime maps in several different apps. This includes commercial geographic information systems such as ArcGIS or MapInfo, free software such as QGIS, and data analysis programmes such as Tableau. So why learn crime mapping in a programming language like R?\nThere are several reasons:\n\nMaking maps using a programming language makes your work much more efficient, especially if (as is common in crime analysis) you need to produce similar maps periodically using updated data, or need to produce multiple similar maps for different areas or crime types.\nR is free. This can be important for people working in agencies with very limited budgets for software for data analysis.\nR has extensive mapping capabilities, supported by a large team of friendly experts who provide online support.\nR is good for other types of data analysis, so everything you learn here can be used for analysing crime data using techniques that are unrelated to maps.\n\nLearning a programming language like R involves a little extra work at the start, but this book is written to make this as easy as possibly by gently introducing you to programming ideas a little at a time. Once you’ve got started, you’ll find mapping crime in this way makes it much easier to advance further in the future."
  },
  {
    "objectID": "index.html#how-to-use-this-book",
    "href": "index.html#how-to-use-this-book",
    "title": "Learn crime mapping with R",
    "section": "How to use this book",
    "text": "How to use this book\nThere are two ways to use this book.\n\nYou can read it as you would any other technical how-to book, by reading through each chapter and working through each exercise in RStudio on your computer or online.\nYou can work through each chapter as an interactive tutorial in RStudio, getting immediate feedback on each exercise. The interactive tutorials also include quizzes to help you check your understanding.\n\nIf you want to use the interactive tutorials, there are a few extra set-up steps to work through at the bottom of this page. They will only take a few minutes.\nI recommend using the interactive tutorials if you can. The interactive tutorials are used for teaching crime mapping to BSc Crime and Security Science students at University College London so they have been tested by hundreds of people learning crime mapping before you."
  },
  {
    "objectID": "07_handling_bugs/index.html#introduction",
    "href": "07_handling_bugs/index.html#introduction",
    "title": "1  Handling bugs in your code",
    "section": "1.1 Introduction",
    "text": "1.1 Introduction\nIn this tutorial we will learn how to deal with bugs in the R code that we write. It’s inevitable that you will make mistakes in the R code that you write. Everyone types the wrong command every now and again, just as everyone sometimes clicks the wrong button in other pieces of software. Learning how to identify and fix bugs is part of the process of learning to code.\nSome errors are easy to identify and easy to fix. Imagine you are working on this dataset of frauds in Kansas City:\n\n\n\n\n\n\n\n\n\n\n\n\n\nuid\noffense_code\noffense_type\ndate\nlongitude\nlatitude\n\n\n\n\n9362175\n26B\ncredit card/automated teller machine fraud\n2015-02-14 11:05:00\n-94.5715\n39.1086\n\n\n9362176\n26B\ncredit card/automated teller machine fraud\n2015-02-14 11:05:00\n-94.5715\n39.1086\n\n\n9362201\n26A\nfalse pretenses/swindle/confidence game\n2015-02-14 13:30:00\n-94.6568\n39.2453\n\n\n9362202\n26A\nfalse pretenses/swindle/confidence game\n2015-02-14 13:30:00\n-94.6568\n39.2453\n\n\n9362213\n26C\nimpersonation\n2015-02-14 15:00:00\n-94.5886\n38.9956\n\n\n9362214\n26C\nimpersonation\n2015-02-14 15:00:00\n-94.5886\n38.9956\n\n\n\n\n\nIf you try to run this code:\n\nselect(frauds, offense_category)\n## Error in `select()`:\n## ! Can't subset columns that don't exist.\n## ✖ Column `offense_category` doesn't exist.\n\n\nYou will get an error message saying something like:\nError: Can't subset columns that don't exist. x Column `offense_category` doesn't exist\n\n\nIt causes an error.\n\nIn this case it is fairly easy to identify that one of the columns you have tried to select does not exist. Maybe you mis-remembered the name of the column. To find out what the correct column name is, you can either print the first few rows of the object (by typing the code head(frauds) into the R console) or use the names() function to print a list of column names present in the data:\n\nnames(frauds)\n## [1] \"uid\"          \"offense_code\" \"offense_type\" \"date\"         \"longitude\"   \n## [6] \"latitude\"\n\n\nChange the following code to correct the mistaken column name:\n\nselect(frauds, offense_category)\n## Error in `select()`:\n## ! Can't subset columns that don't exist.\n## ✖ Column `offense_category` doesn't exist.\n\n\nselect(frauds, offense_type)\n## # A tibble: 6 × 1\n##   offense_type                              \n##   <chr>                                     \n## 1 credit card/automated teller machine fraud\n## 2 credit card/automated teller machine fraud\n## 3 false pretenses/swindle/confidence game   \n## 4 false pretenses/swindle/confidence game   \n## 5 impersonation                             \n## 6 impersonation\n\n\nOther errors will be harder to identify and fix. In this tutorial we will go through the process of debugging – identifying, understanding and fixing errors in your code. Sometimes fixing issues with your code can feel like a bit of a roller coaster, but (like most things) it becomes much easier with practice, and if you approach errors in a systematic way.\n\n\n\n\nStats Illustrations by Allison Horst licensed under the Creative Commons Attribution licence."
  },
  {
    "objectID": "07_handling_bugs/index.html#errors-warnings-and-messages",
    "href": "07_handling_bugs/index.html#errors-warnings-and-messages",
    "title": "1  Handling bugs in your code",
    "section": "1.2 Errors, warnings and messages",
    "text": "1.2 Errors, warnings and messages\nWhen something is not quite right, or just when there is an issue in your code that you should be aware of, R has three ways of communicating with you: messages, warnings and errors.\n\n1.2.0.1 Messages\nMessages are usually for information only and typically don’t require you to take any action. For example, the function get_crime_data() from the crimedata package issues a message to tell you what data it is downloading. It does this because downloading data sometimes takes a few seconds and without a message you might wonder if the code was working.\nBy default, messages are displayed in RStudio in dark red text, although this might vary if you have changed any settings in the Appearance tab of the RStudio Options dialogue. You can generate a message for yourself using the message() function. This is useful if you are writing code and you want to remind yourself of something, or record a particular value. For example, if your code is likely to take a long time to run, you might want to record the time your code started running by generating a message on the first line of your code:\n\nmessage(stringr::str_glue(\"Code started: {Sys.time()}\"))\n## Code started: 2023-03-05 00:24:38\n\nWhen R prints a message about your code, any code underneath the code that generated the message will still run:\n\n2 * 2\n## [1] 4\n\nmessage(\"This is a message. It might be important so make sure you understand it.\")\n## This is a message. It might be important so make sure you understand it.\n\n2 / 2\n## [1] 1\n\n\n\n1.2.0.2 Warnings\nWarnings are generated when there is a potential problem with your code, but the problem was not serious enough to stop your code running entirely. For example, ggplot2 functions like geom_point() will send a warning if some of the rows in your data contain missing values (e.g. if some crimes have missing co-ordinates).\nWarnings are important and you should take time to read and understand them, but it is possible that having done so it will be safe to not take any action. Whether it is safe to take no action will often depend on exactly what you are trying to do, which is why it is important that you understand each warning that you see. For example, if you already know that some rows in your data contain missing values and are happy to plot the remaining values, it will be safe to ignore the warning produced by geom_point(). But if your dataset should not have any missing values in it, you will need to investigate why geom_point() is warning you about missing values and whether those values have been accidentally introduced by some part of your code.\n\nIt is not safe to ignore warnings unless you are sure why they occurred and certain that you don’t need to take any action.\nOne particularly dangerous scenario is where your code produces warnings but still produces what looks like a reasonable result. In these circumstances it can be tempting to ignore the warnings and assume that everything is fine, since the code still produced roughly what you were expecting. However, it’s possible that the plausible answer is nevertheless wrong because of whatever problem is generating the warning in R. Do not assume that warnings are safe to ignore just because they don’t stop your code running.\n\nWarnings are displayed in the same font as messages, but with the text Warning message: at the start. You can generate your own warning messages using the warning() function:\n\nwarning(\"Something might be wrong. Check to make sure.\")\n## Warning: Something might be wrong. Check to make sure.\n\nAs with messages, warnings will not stop your code running. This means that if the warning signalled a genuine problem with your code, the results of the lines underneath the warning might not be reliable. That is why it is important to understand warnings when you see them.\n\n\n1.2.0.3 Errors\nErrors are generated when there is something wrong with your code or the results it produces that means the code cannot continue running any further. An error might occur, for example, because the function read_csv() could not open the requested file (maybe because the file does not exist). In this case, it would make no sense for the rest of the code to run because it probably depends on the data that read_csv() was supposed to load but could not.\nIt would make sense to be able to generate your own errors using the error() function, but this is one of those times when the function to do something in R has a different name from that you might be expecting. In fact, you can generate an error using the stop() function:\n\nstop(\"Something is defintely wrong. Don't go any further until you've fixed it.\")\n## Error in eval(expr, envir, enclos): Something is defintely wrong. Don't go any further until you've fixed it.\n\nThere are two types of errors in R: syntax errors and logical errors. Syntax errors happen when R cannot read your code because of a mistake in how it has been typed out. For example, if you forget to put a comma between the arguments of a function, you will get this error:\n\nmessage(\"A\" \"B\")\n## Error: <text>:1:13: unexpected string constant\n## 1: message(\"A\" \"B\"\n##                 ^\n\nWhen you run R code, R reads all the code and checks if it can be interpreted as valid R code. If not, R will produce a syntax error. Because all of your code is checked for syntax errors before any code is actually run, a syntax error anywhere in your code will stop all of your code running. Syntax errors are typically fairly easy to fix, because they are usually caused by typos.\nThe second type of error is a logical error. This happens when R is able to interpret what you have written, but something is wrong with what you have asked it to do. These are called logical errors because there is usually some problem with the logic of what you are asking R to do. Like syntax errors, logical errors can be caused by typos, but logical errors can also have many other causes.\nThere is a saying in programming that a computer will do exactly what you tell it to do, which may not be the same thing as what you wanted it do. Logical errors happen when you have told R to do something that it cannot do. For example, you might be asking R to multiply together a numeric value and a character value, which is illogical.\nSince every step in your code depends on the steps that went before it, it is only possible to identify a logical error during the process of running the code. This means that a lot of your code might run successfully before an error occurs.\nLogical errors are typically harder to fix than syntax errors are, because fixing a logical error involves understanding (a) what you have asked R to do and (b) the current state of everything in your code at the moment when the error occurs. Fortunately, there are lots of ways to identify and fix logical errors.\nNow we know what errors, warning and messages are, we need to find out how to deal with them when they happen."
  },
  {
    "objectID": "07_handling_bugs/index.html#finding-problems",
    "href": "07_handling_bugs/index.html#finding-problems",
    "title": "1  Handling bugs in your code",
    "section": "1.3 Finding problems",
    "text": "1.3 Finding problems\nIf an error or warning has a simple cause, such as the example of the incorrect column name in the previous section, you can just fix the problem and re-run the code. For problems that are more difficult to handle, you will need to follow a step-by-step process to find and fix them. Think of this as like being a mechanic fixing a car – first you work out what the problem is, then you fix it.\nIf you code only has one line, it will probably be obvious where any problem lies. But most of your code does several things to achieve a particular goal, such as making a map. The first task in dealing with a problem is therefore to work out exactly which function or other piece of code has caused it. For example, take this data-wrangling code to reduce the size of a dataset and sort it in date order:\n\nlibrary(tidyverse)\n\nfrauds |> \n  select(offense_type, date, longitude, latitude) |> \n  filter(offence_type == \"impersonation\") |> \n  arrange(date)\n## Error in `filter()`:\n## ℹ In argument: `offence_type == \"impersonation\"`.\n## Caused by error:\n## ! object 'offence_type' not found\n\nThis code produces a fairly complicated error message. As is often the case, the most useful part of the error message is the last part:\nInput `..1` is `offence_type == \"impersonation\"`\nThis suggests the error is on line 3 of the code, since that is the only line containing the code offence_type == \"impersonation\". To check this, we can comment out that line by placing a # symbol at the start of the line. Do this and re-run the code above – it should now run without a problem.\nNow we know the problem is on the line filter(offence_type == \"impersonation\"), we can look at that line in more detail. Can you spot the problem with that line?\nThe error message in this case has been caused by a typo – the code offence_type == \"impersonation\" uses the British spelling of the word ‘offence’ but in the dataset the variable is spelled using the American English ‘offense’ (you can see the US spelling in the line of code above the line that is causing the error).\n\nIf you correct the spelling in the code above, it should now run without a problem.\n\nSometimes it will not be as clear as this where to start in looking for the problem. For example, if you run this code:\n\nfrauds |> \n  select(offense_code, longitude, latitude) |> \n  filter(offense_code == \"26G\") |> \n  arrange(date)\n## Error in `arrange()`:\n## ℹ In argument: `..1 = date`.\n## Caused by error:\n## ! `..1` must be a vector, not a function.\n\nThe error message produced suggests the problem is with the arrange() function, but everything is correct with that function since arrange() is a correct function name and date is a column in the tibble named frauds. So the problem must lie elsewhere. In cases like this, it can be helpful to comment out all the lines of code except the first one and then uncomment one line at a time until you find the one that causes the problem.\n\nWith the following code, uncomment one line at a time starting on line 2, re-run the code and then uncomment another line. After you run the code each time, look at the output produced until an error occurs or you find that the output is not what you expected.\n\nfrauds |> \n#  select(offense_code, longitude, latitude) |> \n#  filter(offense_code == \"26G\") |> \n#  arrange(date)\n## Error: <text>:5:0: unexpected end of input\n## 3: #  filter(offense_code == \"26G\") |> \n## 4: #  arrange(date)\n##   ^\n\n\n\n\nDid you get an error beginning <text>:5:0: unexpected end of input 3?\n\n\nWhen commenting out lines of code in a code pipeline, it is important to remember to remove the pipe operator |> from the end of the last line of your code. Otherwise you will get an error that begins <text>:5:0: unexpected end of input 3 because R is expecting the final |> to have some code after it. Remember that R will ignore the lines that are commented out, so make sure every line in your pipeline ends with a |> except the last line that is not commented out.\n\n\n\nIf you uncommented all but the last line and run the code, you would see that the line filter(offense_code == \"26G\") results in zero rows of data – all the rows have been removed by the filter() function. This is because 26G is not a valid offence code in this dataset. This means that no rows are kept in the dataset by filter() because there are no rows for which offense_code == \"26G\". In turn, this means there are no rows for arrange() to sort, so running arrange(date) produces an error.\nUncommenting one line at a time until you find an error or output that is not what you expected is a useful way to isolate problems, but it will not always work. In particular, it will not work if the problem is caused by some code that should have been included but is missing from your code entirely. For example, if you try to run the function st_transform() on a tibble without first changing it into an SF object:\n\nlibrary(sf)\n## Linking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n\nfrauds |> \n  select(offense_code, longitude, latitude) |> \n  filter(offense_code == \"26A\") |> \n  st_transform(\"EPSG:3603\")\n## Error in UseMethod(\"st_transform\"): no applicable method for 'st_transform' applied to an object of class \"c('tbl_df', 'tbl', 'data.frame')\"\n\nIn these cases it is particularly useful to check every argument that you have used in a function to track down the error. We will look at this later in this tutorial.\n\n1.3.1 Errors caused by data problems\nMany logical errors will be caused by problems with the code you have written, such as when you try to use a function (e.g. st_intersection()) that only works on an SF object but specify that it should use an object of another type. But sometimes logical errors are caused not by your code, but by a mis-match between the structure that your data actually has and the structure you think your data has. We have already seen an example of this in this tutorial, in the code that tried to refer to a column called offense_category in a dataset that did not have a column with that name.\nErrors caused by a mismatch between the data you think you have and the data you actually have can be particularly frustrating, because there is no way to identify them from just looking at your code. For this reason, it is often important when trying to identify problems in your code to look at the data that is used as the input for your code, and the data that is produced by each step in your code. We used this technique to find the error in our code above that was caused by filter() removing all the rows from a dataset because we had told filter() to only keep rows containing a value that was not present in the dataset. There were no obvious problems with the code we had written, so the only way to find the cause of this problem was to view the dataset returned by the filter() function.\nFinding data problems is one of the reasons why we have used the head() function so often in these tutorials to look at the data at each step in writing a block of code. head() only shows us the first few rows of a dataset, which will not always be enough to identify a problem if the problem is caused by values that are only present in a few rows in the data. For small datasets, we can use the View() function (note the capital letter) to open the entire dataset in a new tab in RStudio.\nFor bigger datasets, this will not work. In that case, we can use the sample_n() or sample_frac() functions from the dplyr package to return a random sample of rows from the data. This can be useful to let us look at a representative sample of a large dataset. sample_n() returns a specific number of rows, e.g. sample_n(frauds, 10) returns 10 rows at random from the frauds dataset. sample_frac() returns a specific proportion of the dataset, e.g. sample_frac(frauds, 0.1) returns a sample of 10% of rows from the data."
  },
  {
    "objectID": "07_handling_bugs/index.html#understanding-problems",
    "href": "07_handling_bugs/index.html#understanding-problems",
    "title": "1  Handling bugs in your code",
    "section": "1.4 Understanding problems",
    "text": "1.4 Understanding problems\nSo far, we have tried two ways to deal with errors:\n\nreading a simple error message that makes the problem obvious,\ncommenting out all the code and then uncommenting one line a time until the error appears.\n\nSometimes you will encounter an error that is still not simple to solve. In this case, it is still important to identify the line of code causing the problem, either by working it out from the text of the error message or commenting out lines of code in turn.\nOnce you know what line is causing the problem, you should focus on understanding exactly what that line of code does. In particular:\n\nWhat data do any functions on that line expect to work on?\nWhat are the values of any arguments to the functions on that line?\nWhat value do the functions on that line produce?\n\nYou can get a lot of help in understanding each function by referring to its manual page. You can access the manual page for a function by:\n\ntyping a question mark followed by the function name without parentheses (e.g. ?mutate) into the R console,\ntyping the function name without parentheses into the search box in the Help panel in RStudio, or\nclicking on the function name anywhere in your R code to place the cursor on the function name, then pressing F1 on your keyboard.\n\nAny of these options opens up a manual page for that function in the Help panel in RStudio. For example, this is the manual page for the str_wrap() function from the stringr package. You can load it by typing ?str_wrap in the R console.\n\n\nDid you get an error beginning No documentation for ‘str_wrap’?\n\n\nWhen you use the ? operator to look up the manual page for a function, R searches through all the functions in the packages you have loaded. If there is no function of the name you have given in the loaded packages, R will produce an error.\nTo access the manual page of a function in a package that is not loaded, you can specify the package in which R should look for the function using the package name and the :: operator (this is the same way that we have already learned to call functions from packages that haven’t been loaded). For example, you can use the code ?stringr::str_wrap to access the manual page for the str_wrap() function from the stringr package even if the stringr package is not loaded.\n\n\n\n\n\n\nAll manual pages have the same format.\n\nDescription gives a short description of what the function does. If multiple related functions are described in a single manual page, this section will explain the differences between them. For example, the manual page for the mutate() function from the dplyr package explains the difference between the mutate() function and the closely related transmute() function.\nUsage shows a single example of how the function works. If there are any optional arguments to the function, this section will show what the default values of those optional arguments are. For example, the manual page for the str_wrap() function from the stringr package show that the default value of the width argument is width = 80.\nArguments gives a list of arguments and the values they can take. It is particularly important to note the type of value expected. So the st_transform() function from the sf package expects an SF object as its first argument – if you provide another sort of object (such as a tibble), this will cause an error.\nValue explains the type of value that the function will return, and whether this value might be of a different type depending on the values of particular arguments. For example, the mean() function in base R returns the arithmetic mean of a vector of numbers. However, if any of the numbers is NA then mean will return NA unless the argument na.rm = TRUE is used. In that case, mean() will ignore the missing values and return the mean of the values that are present.\nExamples gives more examples of how the function can be used.\n\nChecking the manual page for a function can often help you understand why a particular piece of code is not working. If you have set any optional arguments for a function that is producing an error, it may help to reset those arguments to their default values (as shown in the Usage section of the manual page) one by one to understand what effect this has on your code.\nBy reading the error message, isolating the error by commenting out and then reading the manual page, you will be able to fix almost all the errors you will come across in writing R code. Occasionally, however, you will find an error that you just can’t understand. In that case, you will need to get some help from others."
  },
  {
    "objectID": "07_handling_bugs/index.html#how-to-fix-some-common-errors",
    "href": "07_handling_bugs/index.html#how-to-fix-some-common-errors",
    "title": "1  Handling bugs in your code",
    "section": "1.5 How to fix some common errors",
    "text": "1.5 How to fix some common errors\nThere are some mistakes that it is common for people to make when writing code. The table on this page gives some common error messages and how to fix them. Read through this list now but you can also refer back to it later on if you need to. You can download a PDF version of this table for future reference.\nIn these error messages, the code blah represents the function, object or value that the error relates to.\n\n\n\n\n\nError message\nHow to fix it\n\n\n\n\nthere is no package called 'blah'\nYou have either mis-typed the package name or the package is not installed. Check the spelling or use install.packages() to install the package.\n\n\ncould not find function \"blah\"\nYou have either mis-typed the function name or the package containing that function is not loaded. Check the spelling or use library() to load the package.\n\n\nobject 'blah' not found\nYou have either mis-typed the name of the object or the object does not exist. Check the spelling and make sure you have run the code that creates the object. This error can also occur when you have forgotten to put quotes around a character value in an argument, since R treats words without quotes around them as the names of objects. In this case, check that you have used quote marks around any character values in your code.\n\n\n'blah' does not exist in current working directory\nYou have either mis-typed the name of a file that R is trying to access or the file does not exist in the location you have specified. Check the spelling and make sure the file exists.\n\n\nnon-numeric argument to binary operator\nYou have tried to use a mathematical operator such as + or - with a non-numeric value. For example, you might have written the code 1 + blah thinking that blah holds a numeric value, but if blah actually holds a character value then trying to add it to 1 makes no sense. Check that any objects in your code have the values you expect them to.\n\n\nobject of type 'closure' is not subsettable\nYou have tried to use a function as if it is an object, which can happen when you store data in an object that has the same name as an R function (most commonly, when you store some data in an object called data, since there is a function called data()). The circumstances that produce this error are often not simple to understand, so the best way to handle this error is to avoid it by not naming objects using the names of functions.\n\n\nno applicable method for 'blah' applied to an object of class \"blah\"\nSome R functions (called generic functions) work in different ways depending on what type of object you use them on. But if you use a generic function on an object that it does not know how to handle, you will see this error. Check the object(s) that you provided to the function causing the error to make sure it is the type of object you are expecting it to be.\n\n\nunexpected numeric constant in \"blah\", unexpected string constant in \"blah\" or unexpected symbol in \"blah\"\nYou have a typo somewhere in your code. Check the line of code producing the error to make sure it is formatted correctly. The most common typos that cause this error are a missing comma or closing parenthesis, but there are several other typos that can cause similar errors.\n\n\nunused argument (var = \"blah\")\nYou have used an argument name in a function that does not understand it. Check the manual page for that function.\n\n\nargument \"blah\" is missing, with no default\nYou have used a function without providing all the necessary arguments. Check the manual page for that function.\n\n\nThe pipe operator requires a function call as RHS\nThere is a pipe operator at the end of the final line of a code pipeline (or what R thinks should be the final line)."
  },
  {
    "objectID": "07_handling_bugs/index.html#getting-external-help",
    "href": "07_handling_bugs/index.html#getting-external-help",
    "title": "1  Handling bugs in your code",
    "section": "1.6 Getting external help",
    "text": "1.6 Getting external help\nIf you cannot fix an error using any of the techniques we have already covered, it is probably time to get some help from others. Fortunately, one of the big benefits of using R is that there is a friendly, welcoming community of R coders online who are willing to help fix problems. Almost everyone in this community will remember when they were knew to using R and so will be gentle with people who are asking their first question.\n\n1.6.1 Reproducible examples\n\nOne of the things that makes it much more likely that you will find help with your problem in the R community is if you phrase your plea for help in a way that makes it easier to help you. We can do this by providing a reproducible example or reprex of our problem (also sometimes called a minimum working example).\nProducing a reprex makes it much easier for someone to understand your issue. This not only makes it easier for someone to help you, but also shows that you know it will make it easier for them and that you value their time.\n\nImagine that you’ve made a cake, and for some reason it’s turned out absolutely awful – we’re talking completely inedible. Asking a question without a reprex is like asking, “Why didn’t my cake turn out right?” – there are hundreds of possible answers to that question, and it’s going to take a long time to narrow in on the exact cause for your inedible cake creation.\nAsking a question with a reprex is like asking, “My cake didn’t turn out, and here’s the recipe I used and the steps that I followed. Where did I go wrong?” Using this method is going to significantly increase the likelihood of you getting a helpful response, faster!\n\nTo make a reprex, we have to do two things:\n\nRemove everything from our code that does not contribute to causing the error. We do this by removing each line from our code and only keeping those lines that are necessary to produce the error – this is why a reproducible example is sometimes called a minimum working example.\nMake sure that someone trying to help us can reproduce the issue on their own computer even if they don’t have access to the particular dataset we are using. We do this by replacing our own dataset with a publicly available one, preferably one of the datasets that are built into R for exactly this purpose.\n\nWatch this video to see the process of making a reprex in RStudio:\n\n\n\n1.6.2 Reproducible code\nOur first step is to remove every line from our code that isn’t necessary to produce the error. For example, run the following code to see what error it produces.\n\n\n\n\n# Load packages\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(readr)\n\n# Load a dataset from your computer and wrangle it\nroad_deaths <- read_csv(\"road_deaths_data.csv\") |> \n  janitor::clean_names() |> \n  rename(ksi_drivers = drivers, ksi_pass_front = front, ksi_pass_rear = rear) |> \n  select(-petrol_price, -van_killed) |> \n  mutate(\n    law = as.logical(law),\n    ksi_driver_rate = ksi_drivers / (kms / 1000)\n  )\n## Rows: 192 Columns: 9\n## ── Column specification ────────────────────────────────────────────────────────\n## Delimiter: \",\"\n## dbl  (8): DriversKilled, drivers, front, rear, kms, PetrolPrice, VanKilled, law\n## date (1): month_beginning\n## \n## ℹ Use `spec()` to retrieve the full column specification for this data.\n## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n# Make a time-series chart of two continuous variables, coloured by a \n# categorical variable, then add a trend line\nroad_deaths + \n  ggplot(aes(x = month_beginning, y = ksi_driver_rate)) + \n  geom_point(aes(colour = law)) + \n  geom_smooth() +\n  scale_x_date(date_breaks = \"2 years\", date_labels = \"%Y\") +\n  scale_y_continuous(labels = scales::comma_format(), limits = c(0, NA)) +\n  scale_colour_brewer(type = \"qual\") +\n  labs(\n    x = NULL, \n    y = \"drivers killed or seriously injured per 1,000km travelled\", \n    colour = \"after seat belts made mandatory\"\n  ) +\n  theme_minimal() +\n  theme(\n    axis.line.x = element_line(colour = \"grey90\"),\n    axis.ticks = element_line(colour = \"grey90\"),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    legend.position = \"bottom\"\n  )\n## Error in `fortify()`:\n## ! `data` must be a <data.frame>, or an object coercible by `fortify()`,\n##   not an S3 object with class <uneval>.\n## ℹ Did you accidentally pass `aes()` to the `data` argument?\n\nAs you can see, this code produces an error message that is not easy to decipher, so we might need help to deal with it. As the first stage to making a reprex, remove all the lines of the code above that it is possible to remove while still producing the same error. If the error disappears and the chart is produced successfully, you have probably found the line that contains the error. If you remove a line and the code starts to produce a different error, you have removed a line that is needed to produce the original error and should put that line back into the code.\nIt is actually possible to remove a lot of the original code and still produce the same error. You can remove:\n\nAll the lines of code that fine-tune the appearance of the chart (lines 23–38 above).\nThe line creating the trend line (line 22).\nThe code that wrangles our data in ways that don’t affect the error (lines 9–15).\nThe line that loads the dplyr package (line 2), since we are no-longer using the data wrangling functions from that package.\n\nWe cannot remove the code that loads necessary packages (lines 3 and 5), loads the data (line 8) or produces the basic unformatted chart (lines 19–21), because if we remove any of those then the error message changes or disappears.\nThis leaves us with the following code, which produces the same error message but is much easier for someone to check for errors because it is much shorter. Because we have removed the data-wrangling code, we have had to change the name of the argument on line 20 of the code above from y = ksi_driver_rate to y = drivers, since the column ksi_driver_rate is no longer in the data.\n\nIf we forgot to change y = ksi_driver_rate to y = drivers then the code would still produce an error, but it would be a different error. The purpose of producing a reprex is to find the minimum code that still produces the same error we are interested in. If you remove a line of code and the error message you see changes, put that line of code back.\n\nIf this shortened code were to run successfully then the resulting chart would look quite different to the original chart we wanted, but that does not matter because what we are interested in is showing code that produces a specific error. If you run this code, you will see it produces the same error as the code above.\n\n# Load packages\nlibrary(ggplot2)\nlibrary(readr)\n\n# Load a dataset from your computer and wrangle it\nroad_deaths <- read_csv(\"road_deaths_data.csv\")\n## Rows: 192 Columns: 9\n## ── Column specification ────────────────────────────────────────────────────────\n## Delimiter: \",\"\n## dbl  (8): DriversKilled, drivers, front, rear, kms, PetrolPrice, VanKilled, law\n## date (1): month_beginning\n## \n## ℹ Use `spec()` to retrieve the full column specification for this data.\n## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n# Make a time-series chart of two continuous variables, coloured by a \n# categorical variable, then add a trend line\nroad_deaths +\n  ggplot(aes(x = month_beginning, y = drivers)) + \n  geom_point(aes(colour = law))\n## Error in `fortify()`:\n## ! `data` must be a <data.frame>, or an object coercible by `fortify()`,\n##   not an S3 object with class <uneval>.\n## ℹ Did you accidentally pass `aes()` to the `data` argument?\n\n\n\n1.6.3 Reproducible data\nOur shortened code would make a great reproducible example except for one thing: the data file road_deaths_data.csv only exists on our computer. This means the example is not actually reproducible, since anyone trying to run this code on their computer to identify the error would find that they instead got a different error saying that the file road_deaths_data.csv was not found.\nYou could deal with this by uploading your dataset to a website and then having the read_csv() function read it from that URL. But you might not want to share your data (perhaps it is sensitive in some way), or your dataset might be too large to post online. For this reason, many R packages come with toy datasets that can be used in learning or in testing for errors. You can see a list of all the toy datasets available in the packages you have loaded by typing data() in the R console. This will produce a file that gives the name and description of each available dataset.\nTo use one of these toy datasets, you just use the the name of the dataset as you would use any other R object (like the road_deaths object we created above). One commonly used toy dataset is the mpg dataset from the ggplot2 package, which contains fuel economy data for 38 models of car.\nThe data in this dataset are on a completely different topic to the data we were trying to use, but this does not matter as long as the data contains variables of the same type (numeric, character, etc.) as the original data. We can see what variables are in the mpg dataset using the head() function as usual.\n\nlibrary(ggplot2)\n\nhead(mpg)\n## # A tibble: 6 × 11\n##   manufacturer model displ  year   cyl trans      drv     cty   hwy fl    class \n##   <chr>        <chr> <dbl> <int> <int> <chr>      <chr> <int> <int> <chr> <chr> \n## 1 audi         a4      1.8  1999     4 auto(l5)   f        18    29 p     compa…\n## 2 audi         a4      1.8  1999     4 manual(m5) f        21    29 p     compa…\n## 3 audi         a4      2    2008     4 manual(m6) f        20    31 p     compa…\n## 4 audi         a4      2    2008     4 auto(av)   f        21    30 p     compa…\n## 5 audi         a4      2.8  1999     6 auto(l5)   f        16    26 p     compa…\n## 6 audi         a4      2.8  1999     6 manual(m5) f        18    26 p     compa…\n\nFrom this, we can see that there is a year variable that we can use as a substitute for the month_beginning variable in our original code, a variable called hwy that is numeric and so can be substituted for the drivers variable in our code, and a categorical variable called trans that we can substitute for the law variable in our data. This means we can use this data instead of our own data, knowing that anyone on any computer with the ggplot2 package installed can run the code and should get the same result.\n\nChange the code below so that it uses the mpg dataset rather than loads data from the road_deaths_data.csv file. You will need to change the variable names in the stack of ggplot() functions.\n\n# Load packages\nlibrary(ggplot2)\nlibrary(readr)\n\n# Load a dataset from your computer and wrangle it\nroad_deaths <- read_csv(\"road_deaths_data.csv\")\n## Rows: 192 Columns: 9\n## ── Column specification ────────────────────────────────────────────────────────\n## Delimiter: \",\"\n## dbl  (8): DriversKilled, drivers, front, rear, kms, PetrolPrice, VanKilled, law\n## date (1): month_beginning\n## \n## ℹ Use `spec()` to retrieve the full column specification for this data.\n## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n# Make a time-series chart of two continuous variables, coloured by a \n# categorical variable\nroad_deaths +\n  ggplot(aes(x = month_beginning, y = drivers)) + \n  geom_point(aes(colour = law))\n## Error in `fortify()`:\n## ! `data` must be a <data.frame>, or an object coercible by `fortify()`,\n##   not an S3 object with class <uneval>.\n## ℹ Did you accidentally pass `aes()` to the `data` argument?\n\n\n\nWe can change our existing reprex code to use the mpg dataset rather than load data from the road_deaths_data.csv file by changing the variable names in the ggplot() stack.\n\n\n# Load packages\nlibrary(ggplot2)\n\n# Make a time-series chart of two continuous variables, coloured by a \n# categorical variable\nmpg +\n  ggplot(aes(x = year, y = hwy)) + \n  geom_point(aes(colour = trans))\n## Error in `fortify()`:\n## ! `data` must be a <data.frame>, or an object coercible by `fortify()`,\n##   not an S3 object with class <uneval>.\n## ℹ Did you accidentally pass `aes()` to the `data` argument?\n\nWe have now managed to reduce our original 37 lines of code down to 8 lines, as well as making the example reproducible by using a widely available toy dataset. The shorter code still produces the same error while being much easier to read, so we are much more likely to get help quickly than if we had just sent someone our original code.\nMost of the time, the act of producing a reprex will be enough for us to find and fix the error without any external help. Can you see the problem with our code that is making this error happen? If not, we will reveal it at the end of this tutorial.\n\n\n1.6.4 Checking your reprex is reproducible\nNow that you have the minimum code needed to reproduce the error, it’s almost time to share it with people who can help you. But before you do that, it’s worth checking that the code is truly reproducible. To do this we will use the reprex package, which is part of the tidyverse suite of packages you already have installed.\n\n\n\n\nTo use the reprex package, first put your code in a separate R document in the Source panel in RStudio. Open a new R script in RStudio now and paste the code from the last exercise into it. Once you’ve done that, select all the code in that document. Now click the Addins button in RStudio and scroll down until you can choose Reprex selection.\nAfter a few seconds, some code should appear in the RStudio Viewer panel showing your code and the error message that it produces. This code has also been copied to your computer clipboard so that you can paste it into an email or web form when you are asking for help.\nIf the error message that you see along with the code in the Viewer panel is not the error message you were expecting, your example is not yet reproducible. For example if you tried to run the Reprex selection command on the original code that we started this section with, we would get an error message 'road_deaths_data.csv' does not exist in current working directory.\nOnce your reprex produces the same error as the code you originally had the issue with, you’re ready to share it to get help.\n\nStats Illustrations by Allison Horst licensed under the Creative Commons Attribution licence."
  },
  {
    "objectID": "07_handling_bugs/index.html#sources-of-help",
    "href": "07_handling_bugs/index.html#sources-of-help",
    "title": "1  Handling bugs in your code",
    "section": "1.7 Sources of help",
    "text": "1.7 Sources of help\nIf you are being taught R by a formal instructor, or you have friends or colleagues who can help, they will probably be the first people that you go to for help.\nIf this doesn’t work, or if you are the most proficient R user that you know, you might need another place to turn to. Fortunately, R has a large community of volunteers who will help you. Before you ask people online for help, it’s important to check that someone hasn’t already asked the same question and had it answered. Duplicate questions increase the workload of the volunteers who answer questions and slow everything down, so if your question has frequently been answered already it’s possible your question will just be ignored.\nTo find out if there is an answer to your question, the easiest thing to do is to search the error message online. Google, or another search engine of your choice, is definitely your friend. If you search online for the error message that was produced by our reprex code, you will see that there are over 100 pages discussing this error message and how to fix it.\n\n1.7.0.1 Stack Overflow\nLet’s imagine, though, that there were no relevant hits when we searched for the error message, or that none of the results was useful. In that case, we need to pose a new question to the R community. The place to find the largest slice of that community is probably the website Stack Overflow. This is a website for people who are writing code in any programming language imaginable to get help. It is part of the larger Stack Exchange Network of question-and-answer websites covering everything from travel to veganism.\nTo ask a new question on Stack Overflow, go to stackoverflow.com/questions/ask and create an account or log in. You will now be asked to complete a short form with your question. Questions are more likely to get an answer faster if you:\n\nGive the question a specific title. Over 20 million questions have been asked on Stack Overflow since it launched, so a generic title like ‘Help’, ‘R error’ or even ‘ggplot error’ will not help other people find your question. Look at some recent questions about R on Stack Overflow to get some ideas on what title to give for your question.\nIn the body of your question, briefly (2–3 lines should do it) explain what you were trying to do, then paste the reprex output that the Reprex selection addin copied to your clipboard into the question body box underneath your brief explanation. You will see that Stack Overflow recognises the format of your code and shows you a preview of it underneath the question box.\nFinally, add the tag r to the Tags box so that people know your question is about coding in R. This is crucial – if you do not tag your question as being about R, it is very unlikely that volunteers who know about R will be able to find your question.\n\nSubmit your question and wait for an answer. As soon as someone answers your question, or comments on it to ask for more detail, you will get an email alert. Many questions are typically answered within a few hours. Hopefully this will help you get to the final stage of the emotional roller coaster of debugging:\n\n\n\n\nStats Illustrations by Allison Horst licensed under the Creative Commons Attribution licence."
  },
  {
    "objectID": "07_handling_bugs/index.html#in-summary",
    "href": "07_handling_bugs/index.html#in-summary",
    "title": "1  Handling bugs in your code",
    "section": "1.8 In summary",
    "text": "1.8 In summary\n\n1.8.0.1 A workflow for handling errors in R\n\nWhen you run some code in R and it produces an error, follow the steps learned in this tutorial to identify and fix the problem.\n\nRead the error message and fix any obvious problems.\nMake sure your code follows the style guide introduced in the previous tutorials, which will make it easier to see where there might be problems, especially those caused by typos. In particular, make sure that each function is on a separate line so you can comment them out individually.\nComment out all the lines of your code. Uncomment each line in turn (starting with the first line), re-running the code each time until you see the error you’re trying to understand. Now you know which line is likely to be causing the problem.\nIf the error message is one of the common errors explained in this tutorial, follow the steps outlined in the previous section to fix it.\nIf that does not fix the problem, read the manual page for the function that you think is causing the problem. Check that the values you have passed to each argument are what the function needs in order to work.\nIf that does not fix the problem, create a reproducible example by removing all the parts of your code not needed to create the error. Often, the act of creating a reproducible example will help you fix the problem, but if not then you can use it to get help from others.\n\nYou will be able to fix almost all the errors in your code by following the early steps in this list. Only quite rarely will you need to post a reprex online to get help.\n\n\n\n1.8.0.2 What caused the error in our reproducible example?\nThe error in our reproducible example was very simple, but quite difficult to spot. On line 7 of the code below, we try to add the ggplot() function to the mpg object using the + operator when what we wanted to do was pass the mpg object to the ggplot() function using the |> operator. R does not know how to add a dataset to a function in this way so it produced an error message.\nIf you replaced + with |> on line 6 of the code below, the code would now run normally. Since we have removed almost all of our original code to make a reproducible example, the resulting plot looks nothing like what we wanted. This does not matter – when we are producing a reprex we only care about reliably producing the same error. Now that we have fixed the error, we could go back and fix the original code to produce the chart we wanted.\n# load packages\nlibrary(ggplot2)\n\n# make a time-series chart of two continuous variables, coloured by a \n# categorical variable\nmpg + # <---- THE `+` OPERATOR HERE SHOULD BE A `|>` OPERATOR INSTEAD\n  ggplot(aes(x = year, y = hwy)) + \n  geom_point(aes(colour = trans))\nThe mistake in this code is a very easy one to make, because what + does inside a ggplot() stack is so similar to what |> does in passing the result of one function to the next function in an data-wrangling pipeline. Remember that we only use + to combine functions inside a ggplot() stack, and use |> to combine functions everywhere else.\n\nIn this tutorial we have learned how to handle messages, warnings and errors in R. We have learned to take time to understand error messages, to isolate errors so that we can better understand them, to use manual pages for functions to check that every argument is correct, and how to write reproducible examples so that we can get help online. This will help you become a more independent coder.\n\n\nFor more information on writing reproducible examples, see:\n\nWatch the webinar Creating reproducible examples with reprex by Jenny Bryan.\nRead the Reprex do’s and don’ts on the reprex package website."
  },
  {
    "objectID": "appendices/read_functions.html",
    "href": "appendices/read_functions.html",
    "title": "Appendix A — Functions for reading data into R",
    "section": "",
    "text": "R can read data in many different formats. Different functions (often from different packages) are needed to read files of different formats. These are some of the functions needed to read common types of file used in data analysis, including spatial data formats.\n\n\n\n\n\n\n  Functions for reading data into R\n  \n  \n    \n      Data file type\n      Package\n      Function\n      Can load compressed files?\n      Can load files from URL?\n    \n  \n  \n    Comma-separated values (.csv)\n\nreadr\n\nread_csv() (data from English-speaking countries) or read_csv2() (data from elsewhere)\n\nyes\n\nyes\n\n    Fixed-width files (usually .txt)\n\nreadr\n\nread_fwf()\n\nyes\n\nyes\n\n    GeoJSON (.geojson)\n\nsf\n\nread_sf()\n\nno\n\nyes\n\n    GeoPackage (.gpkg)\n\nsf\n\nread_sf()\n\nno\n\nyes\n\n    Google Sheets\n\ngooglesheets4\n\nread_sheet()\n\nn/a\n\nyes\n\n    HTML (.htm or .html)\n\nxml2\n\nread_html() (probably used with functions from the rvest package)\n\nn/a\n\nyes\n\n    JSON (.json)\n\njsonlite\n\nread_json()\n\nyes\n\nyes\n\n    Microsoft Excel (.xlsx or .xls)\n\nreadxl\n\nread_excel()\n\nno\n\nno\n\n    OpenDocument Spreadsheet (.ods)\n\nreadODS\n\nread_ods()\n\nno\n\nyes\n\n    R Data (.rds)\n\nreadr\n\nread_rds()\n\nn/a\n\nyes\n\n    SAS (.sas7bdat)\n\nhaven\n\nread_sas()\n\nyes\n\nyes\n\n    Shapefile (.shp)\n\nsf\n\nread_sf()\n\nno\n\nno\n\n    SPSS Statistics (.sav)\n\nhaven\n\nread_sav()\n\nyes\n\nyes\n\n    Stata (.dta)\n\nhaven\n\nread_dta()\n\nyes\n\nyes\n\n    Tab-separated values (.tsv or .tab)\n\nreadr\n\nread_tsv()\n\nyes\n\nyes\n\n    XML (usually .xml)\n\nxml2\n\nread_xml()\n\nyes\n\nyes"
  }
]